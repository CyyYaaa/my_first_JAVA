代码随想录刷题

# 动态规划

*动态规划五步曲*

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 509.斐波那契数列

![image-20240606094531313](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606094531313.png)

## 70.爬楼梯

![image-20240606094657934](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606094657934.png)



## 746.使用最小花费爬楼梯

![image-20240606094930193](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606094930193.png)

## 62.不同路径

![image-20240606095128687](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606095128687.png)

## 63.不同路径Ⅱ

![image-20240606095319436](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606095319436.png)

## 343.整数拆分

![image-20240606095600019](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606095600019.png)

## 96.不同的二叉搜索树

![image-20240606100025567](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606100025567.png)

## 198.打家劫舍

![image-20240606100227118](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606100227118.png)

## 213.打家劫舍Ⅱ

![image-20240606100445869](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606100445869.png)

## 337.打家劫舍Ⅲ

![image-20240606100640438](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606100640438.png)

## 121.买卖股票的最佳时机

![image-20240606101841087](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606101841087.png)

## 122.买卖股票的最佳时机Ⅱ

![image-20240606102117763](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606102117763.png)

## 123.买卖股票的最佳时机Ⅲ

![image-20240606102244658](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606102244658.png)

## 188.买卖股票的最佳时机Ⅳ

![image-20240606102508352](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606102508352.png)

## 309.买卖股票的最佳时机含冷冻期

![image-20240606102813808](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606102813808.png)

## 714.买卖股票的最佳时机含手续费



![image-20240606102948858](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606102948858.png)

## 300.最长递增子序列

![image-20240606104849682](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606104849682.png)

## 674.最长连续递增序列

![image-20240606105207303](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606105207303.png)

## 718.最长重复子数组

![image-20240606110514003](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606110514003.png)



## 1143.最长公共子序列

![image-20240606111342036](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606111342036.png)



## 1035.不相交的线

![image-20240606111723798](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606111723798.png)



## 53.最大子数组和

![image-20240606112518324](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606112518324.png)



## 115.不同的子序列

![image-20240606120327559](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606120327559.png)



## 392.判断子序列

![image-20240606114715406](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606114715406.png)



## 583.两个字符串的删除操作

![image-20240606122028602](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606122028602.png)



## 72.编辑距离

![image-20240606123009735](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606123009735.png)



## 647.回文子串（复习

![image-20240609103721465](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240609103721465.png)

![image-20240606131120302](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606131120302.png)



## 516.最长回文子序列（复习

![image-20240606132024639](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606132024639.png)



## 背包问题--01背包

### 416. 分割等和子集

![image-20240704161721447](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240704161721447.png)



### 1049. 最后一块石头的重量

![image-20240704164344066](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240704164344066.png)



### 494. 目标和

![image-20240704171259950](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240704171259950.png)



### 474. 一和零

![image-20240704174015748](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240704174015748.png)



## 完全背包

### 518. 零钱兑换Ⅱ

和494.目标和类似，唯一区别就是每个物品都可以取无限次

完全背包问题中两层for循环是可以颠倒的

但是本题中我们是外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）

因为本题属于组合问题，要是先遍历背包再遍历物品则变成了排列问题

![image-20240705180142690](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240705180142690.png)



### 377. 组合总和Ⅳ

爬楼梯问题的进阶版（一步最多可以爬m个楼梯，target为楼梯总数）

这道题求排列数

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

![image-20240705181935025](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240705181935025.png)



### 卡码网57. 爬楼梯进阶版

![image-20240705183344635](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240705183344635.png)



### 322. 零钱兑换

![image-20240705185520695](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240705185520695.png)



### 279. 完全平方数

和322.零钱兑换一样

![image-20240705190400503](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240705190400503.png)





# 二叉树

## 二叉树的前中后序遍历的递归和迭代

https://blog.csdn.net/weixin_46743838/article/details/135479688



## 107.二叉树的层序遍历Ⅱ

![image-20240611115247492](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611115247492.png)



## 199.二叉树的右视图

![image-20240611121336554](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611121336554.png)



## 116.填充每个节点的下一个右侧节点指针(复习)

![image-20240611123519896](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611123519896.png)



## 104.二叉树的最大深度

递归  迭代

![image-20240611134754187](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611134754187.png)

![image-20240611125541371](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611125541371.png)



## 559.N叉树的最大深度

递归＋迭代

![image-20240611135256172](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611135256172.png)



![image-20240611135401551](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611135401551.png)



## 111.二叉树的最小深度

递归＋迭代

![image-20240618160130931](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240618160130931.png)

需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点

![image-20240611125800646](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611125800646.png)



## 226.翻转二叉树

![image-20240611131131767](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611131131767.png)



## 101.对称二叉树

    1.递归
    本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。
    正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。
    但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。
    2.迭代
    通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等
    	--用双端队列实现 模拟栈
    	--用普通队列实现
![image-20240611133332180](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611133332180.png)

![image-20240611134416205](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611134416205.png)



## 222.完全二叉树的节点个数

![image-20240611140811621](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611140811621.png)

![image-20240611141649959](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240611141649959.png)





## 110.平衡二叉树

与104.二叉树的最大深度思路一样，只是增加了判断平衡的逻辑

![image-20240612201348765](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240612201348765.png)





## 257.二叉树的所有路径（复习

![image-20240612202926590](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240612202926590.png)



## 404.左叶子之和

![image-20240612203622777](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240612203622777.png)



## 513.找树左下角的值

递归没怎么看

![image-20240612205041841](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240612205041841.png)



## 112.路径总和

![image-20240613135056566](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613135056566.png)





## 113.路径总和Ⅱ（复习

![image-20240613155057554](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613155057554.png)





## 105.从前序与中序遍历序列构造二叉树（自己的过不了

![image-20240613162003370](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613162003370.png)



## 106.从中序与后序遍历序列构造二叉树

![image-20240613162149008](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613162149008.png)





## 654.最大二叉树

![image-20240613164343502](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613164343502.png)



## 617.合并二叉树

![image-20240613165311529](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613165311529.png)





## 700.二叉搜索树中的搜索

![image-20240613170159500](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613170159500.png)



## 98.验证二叉搜索树

遇到 搜索树，一定想着中序遍历，这样才能利用上特性.如果中序遍历下元素是单调递增的，那它就是一颗二叉搜索树。

![image-20240613170901844](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613170901844.png)





## 530.二叉搜索树的最小绝对差

![image-20240617110818784](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617110818784.png)



## 501.二叉搜索树中的众数（复习

 *利用二叉搜索树的特性 和记录众数的一个技巧 一次遍历解决*

![image-20240617113825000](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617113825000.png)



## 236.二叉树的最近公共祖先

![image-20240617114940183](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617114940183.png)



## 235.二叉搜索树的最近公共祖先

![image-20240617122319396](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617122319396.png)





## 701.二叉搜索树中的插入操作（复习

![image-20240617125623100](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617125623100.png)



## 450.删除二叉搜索树中的节点（复习

![image-20240617132516837](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617132516837.png)



## 669.修剪二叉搜索树（复习

![image-20240617151802735](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617151802735.png)



## 108.将有序数组转换为二叉搜索树

![image-20240617152855772](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617152855772.png)



## 538.把二叉搜索树转换为累加树

![image-20240617153608210](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617153608210.png)





# 回溯

## 回溯法解决的问题

组合问题：N个数里面按一定规则找出k个数的集合
切割问题：一个字符串按一定规则有几种切割方式
子集问题：一个N个数的集合里有多少符合条件的子集
排列问题：N个数按一定规则全排列，有几种排列方式
棋盘问题：N皇后，解数独等等



## 77.组合

![image-20240618185959555](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240618185959555.png)



## 216.组合总和Ⅲ

![image-20240618191238932](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240618191238932.png)





## 17.电话号码的历史组合

![image-20240618192816300](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240618192816300.png)



## 39.组合总和

![image-20240618200110149](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240618200110149.png)



## 40.组合总和Ⅱ

used[]全局

这道题目和`39.组合总和`如下区别：

1. 本题candidates 中的每个数字在每个组合中只能使用一次。
2. 本题数组candidates的元素是有重复的，而`39.组合总和`是无重复元素的数组candidates

![image-20240620162528698](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620162528698.png)

## 131.分割回文串

![image-20240619232806928](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240619232806928.png)

![image-20240619232815574](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240619232815574.png)



## 93.复原IP地址

![image-20240620155459313](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620155459313.png)

![image-20240620155535130](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620155535130.png)





## 78. 子集

![image-20240620161101376](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620161101376.png)





## 90.子集Ⅱ

![image-20240620162704637](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620162704637.png)



## 491. 非递减子序列（不懂（复习

不懂uset的定义位置 他不也是数层去重吗   只是不能排序而已

与`90.子集II`不同的点

1. 不能排序
2. 不能用之前的used[]数组，而要用set，且set不需要跟着回溯，只负责本层里面取了哪些元素
3. 需要判断每个path中元素个数是否大于等于2
4. 需要判断每个path是否是递增的

![image-20240620165125920](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620165125920.png)



## 46.全排列

![image-20240620170507705](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620170507705.png)

![image-20240620170546920](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620170546920.png)





## 47. 全排列Ⅱ

![image-20240620171818742](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620171818742.png)

————————————

**491.递增子序列** 不能用之前的used[]数组，而要用set，且set不需要跟着回溯，只负责本层里面取了哪些元素 used数组不需要回溯，不需要放在递归参数里面
**46.全排列** used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次 used数组要回溯     可以理解为树枝去自己？！因为每次都是从0开始而不再是startIndex
**47.全排列 II** used数组：去重＋取过的元素不再重复取   used数组要回溯
————————————



## 51.N皇后

*棋盘的宽度(col)就是for循环的长度，递归的深度就是棋盘的高度(row)，这样就可以套进回溯法的模板里了。*

![image-20240620175416403](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620175416403.png)

![image-20240620175444961](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620175444961.png)



# 数组

## 704. 二分查找

![image-20240622141637970](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622141637970.png)



## 34. 在排序数组中查找元素的第一个和最后一个位置

![image-20240622144048119](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622144048119.png)

![image-20240622144133357](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622144133357.png)



## 27. 移除元素

![image-20240622150148323](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622150148323.png)



## 977. 有序数组的平方

![image-20240622151328825](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622151328825.png)



## 209. 长度最小的子数组

![image-20240622153127152](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622153127152.png)



## 59. 螺旋数组Ⅱ（改天做







# 链表

## 203. 移除链表元素

![image-20240622155515263](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622155515263.png)



## 707. 设计链表（改天做





## 206. 反转链表

![image-20240622161631619](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622161631619.png)



## 24. 两两交换链表中的节点（复习

![image-20240622163816327](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622163816327.png)



## 19. 删除链表中的倒数第N个节点

![image-20240622165332616](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622165332616.png)

![image-20240622165417133](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622165417133.png)



## 面试题02.07. 链表相交

![image-20240622165954384](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622165954384.png)



## 142. 环形链表Ⅱ

![image-20240622170917454](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240622170917454.png)





## 242. 有效的字母异位词

当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。
当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

数组
set （集合）
map(映射)
但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。
————————————————

![image-20240624163222455](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624163222455.png)



## 349. 两个数组的交集

![image-20240624164202775](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624164202775.png)



## 202. 快乐数

![image-20240624172206993](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624172206993.png)

![image-20240624172800112](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624172800112.png)

但是不懂为什么fast要先getSum()

## 1. 两数之和

![image-20240624173611207](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624173611207.png)



## 454. 四数相加Ⅱ

![image-20240624175846333](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624175846333.png)



## 383. 赎金信

![image-20240624180426817](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624180426817.png)





## 15. 三数之和（复习

难点1：剪枝操作

难点2：a,b,c三个数的去重（不太理解

基础语法知识：res.add(Arrays.asList(nums[i], nums[left], nums[right])); 

![image-20240624183058955](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624183058955.png)



## 18. 四数之和（复习

难点1：相比于三数之和多嵌套了一层 涉及到2次剪枝和a,b,c,d四个数的去重

难点2：要求四数之和是target，而不再是0，target可正可负，因此影响2次剪枝逻辑

————————————————

五数之和、六数之和等等都采用这种解法。
对于**15.三数之和** ，双指针法就是将原本暴力O(n3)的解法，降为O(n2)的解法，四数之和的双指针解法就是将原本暴力O(n4)的解法，降为O(n3)的解法。
之前我们讲过哈希表的经典题目：**454.四数相加II** ，相对于本题简单很多，因为本题是要求在一个集合中找出四个数相加等于target，同时四元组不能重复。
而454.四数相加II是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于本题还是简单了不少！
————————————————

![image-20240624191118669](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624191118669.png)

![image-20240624191145268](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624191145268.png)



# 字符串

## 344. 反转字符串

![image-20240624192801214](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624192801214.png)



## 541. 反转字符串Ⅱ

![image-20240624194131315](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624194131315.png)



## 151. 反转字符串中的单词（复习

![image-20240625161249161](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240625161249161.png)

![image-20240625161323432](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240625161323432.png)



## 卡码网55 右旋转字符串

![image-20240625164333482](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240625164333482.png)





## 28. 找出字符串中第一个匹配项的下标（KMP（复习

![image-20240625172022807](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240625172022807.png)

![image-20240625172118476](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240625172118476.png)



## 459. 重复的子字符串(KMP（复习

（也就是说数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。）

![image-20240625172905558](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240625172905558.png)

![image-20240625172952551](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240625172952551.png)





# 栈和队列

栈与队列的基本操作：`栈实现队列`，`用队列实现栈`

栈在系统中的应用：`括号匹配问题`、`字符串去重问题`、`逆波兰表达式问题`

两种队列的应用：单调队列和优先级队列：`滑动窗口最大值`，`前K个高频元素`（介绍了两种队列：单调队列和优先级队列，这是特殊场景解决问题的利器，是一定要掌握的。）

## 232. 用栈实现队列

![image-20240625175102236](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240625175102236.png)





## 225. 用队列实现栈

![image-20240625180419253](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240625180419253.png)



## 20.有效的括号

![image-20240627125004607](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240627125004607.png)





## 1047. 删除字符串中的所有相邻重复项

![image-20240627125858188](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240627125858188.png)

![image-20240627161307514](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240627161307514.png)

**string()常见操作**

1.字符串拼接：String str3 = str1 + " " + str2;  // 使用加号连接字符串

2.判断字符串相等 System.out.println(str1.equals(str2));  // false，比较内容是否相同

3.字符串查找和替换

String str = "Java is awesome"; 

boolean contains = str.contains("is");  // 判断是否包含子字符串 

int index = str.indexOf("is");  // 获取子字符串的位置 

String replaced = str.replace("awesome", "great");  // 替换字符串

4.字符串分割

String str = "apple,banana,orange"; String[] fruits = str.split(",");  // 按照逗号分割字符串

5.字符串截取

String sub1 = str.substring(6);  // 从索引6开始截取到末尾，结果是 "World" String sub2 = str.substring(0, 5);  // 从索引0开始到索引5（不包括索引5），结果是 "Hello"

6.字符串转换大小写

String upperCase = str.toUpperCase();  // 转换为大写，结果是 "HELLO" String lowerCase = str.toLowerCase();  // 转换为小写，结果是 "hello"

7.去除字符串首尾空格

String trimmed = str.trim();  // 去除首尾空白，结果是 "Hello"

**stringbuilder常见操作**

1.插入操作sb.insert(5, " World");  // 在索引5处插入字符串

2.删除字符或字符串sb.delete(5, 11);  // 删除索引5到索引11（不包括）之间的字符

3.替换字符串sb.replace(6, 11, "Java");  // 替换从索引6到索引11（不包括）的子串为 "Java"

4.反转字符串sb.reverse();  // 反转字符串

5.清空字符串   sb.setLength(0);  // 清空 StringBuilder 内容

6.删除指定索引处的字符串   sb.deleteCharAt(6); // 删除索引为6处的字符（'W'）



## 150.逆波兰表达式

![image-20240627170518537](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240627170518537.png)



## 239. 滑动窗口最大值

![image-20240627174606496](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240627174606496.png)



## 347. 前K个高频元素（复习

**不熟悉的语法知识**

1. 哈希表的操作：map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
2. 优先队列实现大小顶堆和比较方法的重写
3. 堆的peek() poll() size() add()方法

![image-20240628172635660](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240628172635660.png)



# 贪心

## 455. 分发饼干

![image-20240628174554379](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240628174554379.png)



## 376. 摆动序列（复习

![image-20240629114909225](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629114909225.png)



## 122. 买卖股票的最佳时机Ⅱ

![image-20240629120747174](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629120747174.png)



## 55. 跳跃游戏

![image-20240629121845541](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629121845541.png)



## 45. 跳跃游戏Ⅱ

![image-20240629124108471](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629124108471.png)



## 1005. K次取反后最大化的数组和

**贪心1 **局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。
局部最优可以推出全局最优。
那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。
**贪心2 **那么又是一个贪心：局部最优：只找数值最小的正整数进行反转，当前数值和可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。
————————————————

原文链接：https://blog.csdn.net/weixin_46743838/article/details/135904579

![image-20240629131518697](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629131518697.png)



## 134. 加油站

**局部最优：**当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。
**全局最优：**找到可以跑一圈的起始位置。

![image-20240629133454953](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629133454953.png)



## 135. 分发糖果

这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，如果两边一起考虑一定会顾此失彼。

![image-20240629134150466](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629134150466.png)



## 860. 柠檬水找零

![image-20240629135213300](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629135213300.png)



## 406. 根据身高重建队列（复习

代码中涉及到的一些基础语法知识不是很熟悉：

1. 实现身高从大到小排序，身高相同按第二个维度从小到大排序
2. list转化为二维数组

![image-20240629140311131](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629140311131.png)



## 452. 用最少数量的箭引爆气球

![image-20240629142217411](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629142217411.png)

先将数组按照左边界从小到大排序
对于每个气球所在区间：

- if 左边界大于上个气球右边界 弓箭数加1
- else 更新当前气球的右边界9说明当前气球不需要额外的弓箭，但是我们为了继续判断下一个气球是否需要额外的弓箭，所以要更新右边界）





## 435. 无重叠区间

![image-20240702213551417](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240702213551417.png)



## 763. 划分字母区间

![image-20240702214223604](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240702214223604.png)



## 56. 合并区间

![image-20240702215801029](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240702215801029.png)





## 738. 单调递增的数字（复习

**解题思路**
一旦出现strNum[i - 1] > strNum[i]的情况（非单调递增），首先想让strNum[i - 1]减一，strNum[i]赋值9。
考虑遍历顺序，只有从后向前遍历才能重复利用上次比较的结果。
用一个flag来标记从哪里开始赋值9。



**不熟悉的基础语法知识**
int型数字转换为字符串再转化为字符数组
char[] strN = Integer.toString(n).toCharArray();
字符数组转化为字符串再转化为Int型数字的两种方式
Integer.parseInt(new String(strN));
Integer.parseInt(String.valueOf(chars));



![image-20240702221032972](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240702221032972.png)



## 968. 监控二叉树（先放弃掉了捏
