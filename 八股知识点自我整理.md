知识点整理

# 框架篇（黑马八股+javaguide+卡尔八股

## Spring是如何简化开发的？（Java面试马士兵

IOC

基于POJO的轻量级和最小侵入性编程

通过依赖注入和面向接口实现松耦合

AOP

基于切面和惯例进行声明式事务

通过切面和模板减少样板式代码



## Spring中用到哪些设计模式？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240529185629460.png" alt="image-20240529185629460" style="zoom:67%;" />



## **Spring，Spring MVC，Spring Boot**

Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；

Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题，

因为 Spring 的配置非常复杂，各种xml，properties处理起来比较繁琐。于是为了简化开发者的使用，Spring社区创造性地推出了Spring Boot，它遵循约定优于配置，极大降低了Spring使用门槛，但又不失Spring原本灵活强大的功能，

一句话总结：**Spring MVC和Spring Boot都属于Spring，Spring MVC 是基于Spring的一个 MVC 框架，而Spring Boot 是基于Spring的一套快速开发整合包。**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240529184842094.png" alt="image-20240529184842094" style="zoom:50%;" />

## Spring框架中的单例bean是线程安全的吗

![image-20240510211634225](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240510211634225.png)



## Bean Factory和Factory Bean的区别

首先，Spring 里面的核心功能是 IOC 容器，所谓 IOC 容器呢，本质上就是一个 Bean 的容器或者是一个 Bean 的工厂。它能够根据 xml 里面声明的 Bean 配置进行 bean 的加载和初始化，然后 BeanFactory 来生产我们需要的各种各样的 Bean。

**所以我对 BeanFactory 的理解了有两个**

1.BeanFactory 是所有 Spring Bean 容器的顶级接口，它为 Spring 的容器定义了一套规范，并提供像 getBean 这样的方法从容器中获取指定的 Bean 实例。

2.BeanFactory 在产生 Bean 的同时，还提供了解决 Bean 之间的依赖注入的能力，也就是所谓的DI。

**FactoryBean 是一个工厂 Bean**，它是一个接口，主要的功能是动态生成某一个类型的 Bean 的实例，

也就是说，我们可以自定义一个 Bean 并且加载到 IOC 容器里面。

它里面有一个重要的方法叫 getObject()，这个方法里面就是用来实现动态构建 Bean 的过程。

Spring Cloud 里面的 OpenFeign 组件，客户端的代理类，就是使用了 FactoryBean 来实现的。

以上就是我对这个问题的理解。



## spring IOC和DI

在传统的 Java 程序开发中，我们只能通过 new 关键字来创建对象，这种导致程序中对象的依赖关系比较复杂，耦合度较高。而 IOC 的主要作用是实现了对象的管理，也就是我们把设计好的对象交给了 IOC 容器控制，然后在需要用到目标对象的时候，直接从容器中去获取。有了 IOC 容器来管理 Bean 以后，相当于把对象的创建和查找依赖对象的控制权交给了容器，这种设计理念使得对象与对象之间是一种松耦合状态，极大提升了程序的灵活性以及功能的复用性。

Spring DI（[依赖注入](https://so.csdn.net/so/search?q=依赖注入&spm=1001.2101.3001.7020)）是Spring框架中的一个核心特性，它是实现控制反转（IOC）的具体方式之一。DI指的是通过外部配置或注解的方式，将一个对象所依赖的其他对象（依赖）自动注入到该对象中，而不需要在代码中显式地创建和管理这些依赖对象。

DI 表示依赖注入，也就是对于 IOC 容器中管理的 Bean，如果 Bean 之间存在依赖关系，那么IOC 容器需要自动实现依赖对象的实例注入，通常有三种方法来描述 Bean 之间的依赖关系。

1. 接口注入

2. setter 注入

3. 构造器注入

另外，为了更加灵活地实现 Bean 实例的依赖注入，Spring 还提供了@Resource 和@Autowired 这两个注解。分别是根据 bean 的 id 和 bean 的类型来实现依赖注入。



## spring AOP

### 概念理解

注入目标对象-----注入切面对象-----配置（自动扫包、开启自动生成代理）-----将代理对象取出来执行代码

切面实际就是将目标对象和切面对象进行整合

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240529182735359.png" alt="image-20240529182735359" style="zoom:50%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240529182748457.png" alt="image-20240529182748457" style="zoom:50%;" />

### AOP中的关键术语

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240529182856546.png" alt="image-20240529182856546" style="zoom:67%;" />

### AOP的实现方式

AOP 的常见实现方式有动态代理、字节码操作等方式。

Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 **JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 **Cglib** 生成一个被代理对象的子类来作为代理

**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。** Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。

Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。

### AOP的通知类型

![image-20240508182200753](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240508182200753.png)





1.定义：面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合。@Transactional 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。

2.常见的AOP使用场景：记录操作日志、缓存处理、Spring中内置的事务处理

3.**项目中的使用**

记录操作日志，缓存，spring实现的事务

核心是：使用aop中的环绕通知+切点表达式（找到要记录日志的方法），通过环绕通知的参数获取请求方法的参数（类、方法、注解、请求方式等），获取到这些参数以后，保存到数据库

## spring 事务

问到事务，还应该要提到AOP  动态代理等相关联的点

### spring支持2种类型的事务管理

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240529191246453.png" alt="image-20240529191246453" style="zoom:67%;" />

**编程式事务管理**

通过 `TransactionTemplate`或者`TransactionManager`手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。

**声明式事务管理**

推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于`@Transactional` 的全注解方式使用最多）。如果一个类或者一个类中的 public 方法上被标注`@Transactional` 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被`@Transactional` 注解的 public 方法的时候，实际调用的是，`TransactionInterceptor` 类中的 `invoke()`方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。

![image-20240628124128579](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240628124128579.png)

[`@Transactional` 的作用范围](#transactional-的作用范围)

1. **方法**：推荐将注解使用于方法上，不过需要注意的是：**该注解只能应用到 public 方法上，否则不生效。**

2. **类**：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。

   

[`@Transactional` 的使用注意事项总结](#transactional-的使用注意事项总结)

- `@Transactional` 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；
- 避免同一个类中调用 `@Transactional` 注解的方法，这样会导致事务失效；
- 正确的设置 `@Transactional` 的 `rollbackFor` 和 `propagation` 属性，否则事务可能会回滚失败;
- 被 `@Transactional` 注解的方法所在的类必须被 Spring 管理，否则不生效；
- 底层使用的数据库必须支持事务机制，否则不生效；

### Spring事务传播机制

![image-20240529170442853](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240529170442853.png)

### spring中事务失效的场景

异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出

Spring 默认只会回滚非检查异常，若抛出检查异常，要配置rollbackFor属性为Exception

非public方法导致的事务失效，改为public

![image-20240628124649723](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240628124649723.png)

## Spring中Bean的作用域有哪些？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240529201743429.png" alt="image-20240529201743429" style="zoom:67%;" />



## Bean注入到IOC容器的方式

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240529201948452.png" alt="image-20240529201948452" style="zoom:80%;" />

xml方式注入：常见的方式有：set方法注入、构造方法注入

注解方式注入：@Component+@ComponentScan  一般用于自己写的类

​							@Configuration+@Bean+@ComponentScan 该方法一般用于导入的第三方包里面的组件

​							@import

## spring中bean的生命周期

![image-20240509174317476](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509174317476.png)

![image-20240510213245996](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240510213245996.png)

## spring的循环依赖问题如何解决？（不理解

如果在代码中，将两个或多个 Bean 互相之间持有对方的引用 就会发生循环依赖。循环依赖将会导致陷入死循环。这是 Spring 发生循环依赖的原因。

![image-20240509182422235](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509182422235.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509182511462.png" alt="image-20240509182511462" style="zoom:50%;" />

## spring mvc执行流程

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629170926614.png" alt="image-20240629170926614" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509183614151.png" alt="image-20240509183614151" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509183538727.png" alt="image-20240509183538727" style="zoom:67%;" />

## spring boot自动配置原理

![image-20240509185547584](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509185547584.png)

![image-20240530175525166](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240530175525166.png)



## 如何理解spring boot 中的starter?(不理解)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240530174058950.png" alt="image-20240530174058950" style="zoom:67%;" />



<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240530174235562.png" alt="image-20240530174235562" style="zoom:67%;" />



![image-20240529194046387](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240529194046387.png)



### 如何自定义一个starter?

黑马头条中将MINIO封装为starter

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240530182436407.png" alt="image-20240530182436407" style="zoom:50%;" />

看咪咕视频

1.创建一个maven项目（starter项目）

2.项目中创建自动配置类

​		@Configuration注解进行标注

​		@Bean注解声明需要自动装配的Bean

3.创建spring.factories文件  resources/META-INF目录下，将自动配置类填写到该文件下

4.在其他项目中引入我们的starter组件



### 什么是约定大于配置





## spring，spring mvc，spring boot常见注解

![image-20240509190055114](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509190055114.png)

![image-20240509191442785](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509191442785.png)

![image-20240509191558700](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509191558700.png)





## mybatis执行流程

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620112339485.png" alt="image-20240620112339485" style="zoom:50%;" />

![image-20240509192516810](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509192516810.png)

## mybatis是否支持延迟加载？延迟加载原理说一下

![image-20240509193633179](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509193633179.png)

1. 使用CGLIB创建目标对象的代理对象
2. 当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，执行sql查询
3. 获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240509193704193.png" alt="image-20240509193704193" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240510215240689.png" alt="image-20240510215240689" style="zoom:67%;" />

## Mybatis的一级、二级缓存用过吗？（详见咕泡

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240529201409921.png" alt="image-20240529201409921" style="zoom:80%;" />

![image-20240510221504920](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240510221504920.png)

## **Mybatis 中#{｝和${｝的区别是什么？**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240628125543735.png" alt="image-20240628125543735" style="zoom:50%;" />

\#{}和${}这两个语法是Mybatis实现动态sql的基础

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240530162532488.png" alt="image-20240530162532488" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240601180434772.png" alt="image-20240601180434772" style="zoom:67%;" />

Mybatis会将SQL语句中的#{}转换为问号占位符。

${}形式传参，底层Mybatis做的是字符串拼接操作。

通常不会采用\${}的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用

结论：实际开发中，能用#{}实现的，肯定不用\${}。

特殊情况： 动态的不是值，是列名或者关键字，需要使用\${}拼接

# Redis篇

## 缓存穿透

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240624213528377.png" alt="image-20240624213528377" style="zoom:50%;" />

缓存穿透：查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库。这种情况大概率是遭到了攻击。

**解决方案一：缓存空数据**(查询返回的数据为空，仍把这个空结果进行缓存)

**解决方案二：布隆过滤器**

它的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。

检索的时候，使用同样的方式去映射，只要看到每个映射的位置的值是不是 1，就可以大概知道该元素是否存在集合中了。

如果这些点有任何一个 0，则被检查的元素一定不在；如果都是 1，则被检查的元素很可能存在。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240514165108990.png" alt="image-20240514165108990" style="zoom:80%;" />

## 缓存击穿

缓存击穿：给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把DB压垮

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613182206879.png" alt="image-20240613182206879" style="zoom:67%;" />

解决方案一：加互斥锁；在缓存失效后，通过设置互斥锁确保只有一个请求去查询数据库并更新缓存。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240514165626435.png" alt="image-20240514165626435" style="zoom:67%;" />

## 缓存雪崩

缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。

1.可以给缓存设置过期时间时加上一个随机值时间，使得每个 key 的过期时间分布开来，不会集中在同一时刻失 效；

2.采用限流算法，限制流量；

3.采用分布式锁，加锁访问

解决方案：

![image-20240514170536213](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240514170536213.png)

## 如何保证redis和数据库的一致性（双写一致性

就是一份数据，同时保存在数据库和 Redis 里面，当数据发生变化的时候，需要同时更新 Redis 和 Mysql，由于更新是有先后顺序的，并且它不像 Mysql中的多表事务操作，可以满足 ACID 特性。所以就会出现数据一致性问题。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613185918851.png" alt="image-20240613185918851" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613185934099.png" alt="image-20240613185934099" style="zoom:67%;" />



同步方式

1.延时双删

2.redisson实现的分布式锁

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513172427585.png" alt="image-20240513172427585" style="zoom:67%;" />

异步方式

1.在应用中去写消息队列

无论是先操作缓存，还是先操作数据库，但凡后者执行失败了，我们就可以发起重试，尽可能地去做「补偿」；或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。因为消息队列的特性，正好符合我们的需求：

- **消息队列保证可靠性**：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）
- **消息队列保证消息成功投递**：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）

2.订阅数据库变更日志（例如阿里的 canal），再操作缓存

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513172201269.png" alt="image-20240513172201269" style="zoom:80%;" />

使用这种方案的优点在于：

- **无需考虑写消息队列失败情况**：只要写 MySQL 成功，Binlog 肯定会有
- **自动投递到下游队列**：canal 自动把数据库变更日志「投递」给下游的消息队列

**我们可以得出结论，想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613191102294.png" alt="image-20240613191102294" style="zoom:50%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613191245381.png" alt="image-20240613191245381" style="zoom:50%;" />

## redis的持久化机制

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513180545849.png" alt="image-20240513180545849" style="zoom:50%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613192256218.png" alt="image-20240613192256218" style="zoom:50%;" />

![image-20240513180641938](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513180641938.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513180701199.png" alt="image-20240513180701199" style="zoom:67%;" />

![image-20240513180731766](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513180731766.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613192705795.png" alt="image-20240613192705795" style="zoom:67%;" />



## redis的数据过期策略

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513180956879.png" alt="image-20240513180956879" style="zoom:67%;" />

定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 **定期删除+惰性/懒汉式删除** 。

## redis的数据淘汰策略（假如缓存过多，内存是有限的，内存被占满了怎么办？

![image-20240513181324917](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513181324917.png)

## redis分布式锁的实现（回答要结合业务

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513183942234.png" alt="image-20240513183942234" style="zoom:67%;" />

1.setnx命令实现分布式锁

2.redis的框架redisson实现分布式锁

（1 在redisson中引入看门狗机制给锁续期，控制锁的有效时长

（2 在当前线程持有锁期间，如果有另一个线程来获取锁会获取锁失败，但是它会while循环，不断尝试获取锁

（3 加锁、设置过期时间等操作都是基于lua脚本完成

（4 利用hash结构，记录线程标示和重入次数（可重入

（5 Redlock红锁解决主从数据一致的问题（不推荐）性能差

​				Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。**Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。**即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。

（6 如果业务非要保证强一致性，建议采用zookeeper实现的分布式锁(暂时没了解 javaguide上有)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513183632200.png" alt="image-20240513183632200" style="zoom:67%;" />



<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513183201377.png" alt="image-20240513183201377" style="zoom:67%;" />

## Redis集群有哪些方案？

### 主从复制

主从全量同步    主从增量同步

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240514211428216.png" alt="image-20240514211428216" style="zoom:67%;" />

### 哨兵模式

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240514213341161.png" alt="image-20240514213341161" style="zoom:67%;" />

### 分片集群

主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：海量数据存储问题、高并发写的问题，使用分片集群可以解决上述问题。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240514213746072.png" alt="image-20240514213746072" style="zoom:80%;" />

## Redis是单线程的，但是为什么还那么快？

1. Redis是纯内存操作，执行速度非常快
2. 采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题
3. 使用I/O多路复用模型，非阻塞IO
4. redis内部的数据结构（redis内置了多种优化过后的数据类型/结构实现，性能非常高。

Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”，从而减少对主线程的影响。

虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。

![image-20240417152253122](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240417152253122.png)

**比如说Redis中的String**,虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 **简单动态字符串**（Simple Dynamic String，**SDS**）。SDS 共有五种实现方式，Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。

相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。

![image-20240417152442910](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240417152442910.png)

那既然都这么快了，为什么不直接用 Redis 当主数据库呢？主要是因为内存成本太高且 Redis 提供的数据持久化仍然有数据丢失的风险

## Redis常见阻塞原因总结（javaguide上的

1.O(n)命令

Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令。由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长，从而导致客户端阻塞。

2.AOF重写阻塞

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515141109830.png" alt="image-20240515141109830" style="zoom:50%;" />

3.大key

如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240614120442766.png" alt="image-20240614120442766" style="zoom:50%;" />

4.清空数据库

清空数据库和上面 bigkey 删除也是同样道理，`flushdb`、`flushall` 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。

## Redis除了做缓存，还能做什么？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240514220121229.png" alt="image-20240514220121229" style="zoom:67%;" />

## Redis常见数据类型

**5 种基础数据类型**：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。

**3 种特殊数据类型**：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515133156985.png" alt="image-20240515133156985" style="zoom:50%;" />

Redis 中字符串类型常用命令：

- **SET** key value 					         设置指定key的值
- **GET** key                                        获取指定key的值
- **SETEX** key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒
- **SETNX** key value                        只有在 key    不存在时设置 key 的值

Redis **hash** 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：

- **HSET** key field value             将哈希表 key 中的字段 field 的值设为 value
- **HGET** key field                       获取存储在哈希表中指定字段的值
- **HDEL** key field                       删除存储在哈希表中的指定字段
- **HKEYS** key                              获取哈希表中所有字段
- **HVALS** key                              获取哈希表中所有值

Redis 列表**list**是简单的字符串列表，**按照插入顺序排序**，常用命令：

- **LPUSH** key value1 [value2]         将一个或多个值插入到列表头部
- **LRANGE** key start stop                获取列表指定范围内的元素
- **RPOP** key                                       移除并获取列表最后一个元素
- **LLEN** key                                        获取列表长度
- **BRPOP** key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超    时或发现可弹出元素为止

Redis **set** 是string类型的**无序集合**。**集合成员是唯一的**，这就意味着集合中不能出现重复的数据，常用命令：

- **SADD** key member1 [member2]            向集合添加一个或多个成员
- **SMEMBERS** key                                         返回集合中的所有成员
- **SCARD** key                                                  获取集合的成员数
- **SINTER** key1 [key2]                                   返回给定所有集合的交集
- **SUNION** key1 [key2]                                 返回所有给定集合的并集
- **SREM** key member1 [member2]            移除集合中一个或多个成员

Redis**有序集合zset**是string类型元素的集合，且**不允许有重复成员**。每个元素都会关联一个double类型的分数，通过这个**分数进行排序**。常用命令：

常用命令：

- **ZADD** key score1 member1 [score2 member2]     向有序集合添加一个或多个成员
- **ZRANGE** key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员
- **ZINCRBY** key increment member                              有序集合中对指定成员的分数加上增量 increment
- **ZREM** key member [member ...]                                移除有序集合中的一个或多个成员

# 消息中间件--RabbitMQ

## RabbitMQ消息如何传输？

由于 TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 RabbitMQ 使用信道的方式来传输数据。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，信道是建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。



## RabbitMQ如何保证消息不丢失？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240514152921176.png" alt="image-20240514152921176" style="zoom:80%;" />

生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。

RabbitMQ 自身：持久化、集群、普通模式、镜像模式。

RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制



## 重复消费问题如何解决？

为了防止消息在消费者端丢失，会采用手动回复MQ的方式来解决，同时也引出了一个问题，消费者处理消息成功，手动回复MQ时由于网络不稳定，连接断开，导致MQ没有收到消费者回复的消息，那么该条消息还会保存在MQ的消息队列，由于MQ的消息重发机制，会重新把该条消息发给和该队列绑定的消息者处理，这样就会导致消息重复消费。而有些操作是不允许重复消费的，比如下单，减库存，扣款等操作。
主要分两个思路

**1.确保消费端只执行一次**

一般来说消息重复消费都是在短暂的一瞬间消费多次，我们可以使用 redis 将消费过的消息唯一标识存储起来，然后在消费端业务执行之前判断 redis 中是否已经存在这个标识。

举个例子，订单使用优惠券后，要通知优惠券系统，增加使用流水。这里可以用订单号 + 优惠券 id 做唯一标识。业务开始先判断 redis 是否已经存在这个标识，如果已经存在代表处理过了。不存在就放进 redis 设置过期时间，执行业务。
**2.允许消费端执行多次，保证数据不受影响**

数据库唯一键约束
如果消费端业务是**新增**操作，我们可以利用数据库的唯一键约束，比如优惠券流水表的优惠券编号，如果重复消费将会插入两条相同的优惠券编号记录，数据库会给我们报错，可以保证数据库数据不会插入两条。

数据库乐观锁思想
如果消费端业务是**更新**操作，可以给业务表加一个 version 字段，每次更新把 version 作为条件，更新之后 version + 1。由于 MySQL 的 innoDB 是行锁，当其中一个请求成功更新之后，另一个请求才能进来，由于版本号 version 已经变成 2，必定更新的 SQL 语句影响行数为 0，不会影响数据库数据。

## 死信和死信交换机

（RabbitMQ交换机类型：fanout,  direct,  topic,   headers)

当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：

消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false

消息是一个过期消息，超时无人消费

要投递的队列消息堆积满了，最早的消息可能成为死信

如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为死信交换机（Dead Letter Exchange，简称DLX）。

## RabbitMQ延迟队列

项目中用的redis实现的延迟队列

![image-20240514161406900](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240514161406900.png)

## 消息堆积问题如何解决？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240514161906673.png" alt="image-20240514161906673" style="zoom:67%;" />

## RabbitMQ的高可用机制有了解过吗？

在生产环境下，使用集群来保证高可用性

普通集群、镜像集群、仲裁队列

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240514162522368.png" alt="image-20240514162522368" style="zoom:67%;" />

# 消息中间件--Kafka（看咕泡）

## 为什么要使用消息中间件？（解耦 异步 削峰

**解耦和解偶**： 消息中间件允许不同组件、服务或系统在时间和空间上解耦和解偶。传统的直接通信方式（例如直接调用函数或通过数据库进行通信）会导致系统中各部分之间紧密耦合，一旦其中一个部分出现问题或变化，可能会影响到整个系统。消息中间件通过引入一个消息队列或主题来缓冲和传递消息，使得发送者和接收者不直接依赖彼此的可用性或状态。

**异步通信**： 消息中间件支持异步通信模式，其中发送者和接收者之间的交互是非阻塞的。这种模式对于处理高并发和大规模数据非常重要，因为它允许系统能够继续进行其他工作，而不必等待每个通信操作的完成。

**可靠性和持久性**： 好的消息中间件提供可靠性保证，确保消息在发送后能够安全地传递到接收方，即使在网络或接收方不稳定的情况下也能保证消息不丢失。此外，消息通常可以持久化到磁盘上，以防止数据丢失，这在某些关键应用中尤为重要。

**扩展性和灵活性**： 通过消息中间件，系统可以更容易地扩展和部署新的服务或功能模块。新的服务可以通过订阅消息队列或主题来接收和处理特定类型的消息，而无需修改现有服务或系统的结构。这种灵活性使得系统更容易进行微服务化或实现多个系统之间的集成。

**缓冲和流量控制**： 消息中间件可以作为缓冲层，帮助控制和平衡系统中的流量。它可以限制消息的发送速率，避免瞬时大量请求对系统的冲击，同时通过队列长度或其他机制来平滑处理和处理突发的负载。

## 消息中间件的缺点

消息丢失 重复消费 消息顺序性   一致性问题

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629191652637.png" alt="image-20240629191652637" style="zoom:67%;" />



## 消息中间件间的对比

![image-20240629201353352](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629201353352.png)

--------------------------------------------------------------------------------------------------------------

为什么Kafka的性能高呢？

![image-20240629201625739](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629201625739.png)

![image-20240629201651112](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240629201651112.png)





**RabbitMQ** 中消息只能存储在 **队列** 中，这一点和 **Kafka** 这种消息中间件相反。Kafka 将消息存储在 **topic（主题）** 这个逻辑层面，而相对应的队列逻辑只是 topic 实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。

## Kafka是如何保证消息不丢失的？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617182912582.png" alt="image-20240617182912582" style="zoom:67%;" />



## Kafka如何保证消息的重复消费？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240713172929870.png" alt="image-20240713172929870" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240713173014121.png" alt="image-20240713173014121" style="zoom:67%;" />





## Kafka如何保证消息消费的顺序性？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617184433731.png" alt="image-20240617184433731" style="zoom:67%;" />



## Kafka高可用机制

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617185914879.png" alt="image-20240617185914879" style="zoom:80%;" />



## Kafka的存储结构和日志清理策略

![image-20240617190421311](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617190421311.png)



## Kafka中实现高性能的设计有了解过吗？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240617191439703.png" alt="image-20240617191439703" style="zoom:80%;" />





# 常见集合篇

![image-20240515150325635](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515150325635.png)

## 数组

数组（Array）是一种用连续的内存空间存储相同数据类型数据的线性数据结构。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515150933167.png" alt="image-20240515150933167" style="zoom:50%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515150951859.png" alt="image-20240515150951859" style="zoom:67%;" />

## Arrays.sort()内部的排序算法

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515151217059.png" alt="image-20240515151217059" style="zoom:67%;" />

ps：Arrays.sort() 方法使用的是快速排序算法和归并排序算法，具体使用哪一种算法取决于数组的大小和类型。当数组长度小于 Arrays.MIN_ARRAY_SORT_GRAN 时，使用插入排序算法对其进行排序。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515151446965.png" alt="image-20240515151446965" style="zoom:67%;" />

## ArrayList和Array(数组)的区别

![image-20240515164956275](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515164956275.png)



## ArrayList源码分析

1.成员变量

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515154004900.png" alt="image-20240515154004900" style="zoom:67%;" />

2.构造函数

![image-20240515154107909](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515154107909.png)

3.添加和扩容逻辑

![image-20240515154415858](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515154415858.png)

## ArrayList底层的实现原理是什么

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240708183557418.png" alt="image-20240708183557418" style="zoom:67%;" />

![image-20240708183524508](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240708183524508.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240708183437148.png" alt="image-20240708183437148" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515154816864.png" alt="image-20240515154816864" style="zoom:67%;" />

## 如何实现数组和List之间的转换

数组转List ，使用JDK中java.util.Arrays工具类的asList方法

List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组

Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址

list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响

![image-20240515162944175](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515162944175.png)

## ArrayList和LinkedList的区别是什么？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515163320252.png" alt="image-20240515163320252" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515163353761.png" alt="image-20240515163353761" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240704204924036.png" alt="image-20240704204924036" style="zoom:67%;" />





## 二叉搜索树

二叉搜索树(Binary Search Tree,BST)又名二叉查找树，有序二叉树

在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值而右子树节点的值都大于这个节点的值

没有键值相等的节点

通常情况下二叉树搜索的时间复杂度为O(logn)，但极端情况下会退化为链表，变为O(n)（红黑树的诞生就是为了解决这个缺陷

## 红黑树

红黑树（Red Black Tree）：也是一种自平衡的二叉搜索树(BST)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240516180757841.png" alt="image-20240516180757841" style="zoom:80%;" />

![image-20240516180934373](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240516180934373.png)

## 平衡二叉树（AVL树）

## B树

## B+树

## 什么是哈希表？什么是哈希冲突？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517094641260.png" alt="image-20240517094641260" style="zoom:67%;" />

## HashMap实现原理

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517100741930.png" alt="image-20240517100741930" style="zoom:67%;" />

## HashMap的put方法的具体流程

![image-20240517105345390](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517105345390.png)

![image-20240517105926828](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517105926828.png)

## HashMap的扩容流程

![image-20240517111402156](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517111402156.png)

![image-20240517111529109](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517111529109.png)

## HashMap寻址算法

![image-20240517113129912](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517113129912.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517113248676.png" alt="image-20240517113248676" style="zoom:67%;" />

## HashMap在1.7情况下的多线程死循环问题

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517120151945.png" alt="image-20240517120151945" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517124027115.png" alt="image-20240517124027115" style="zoom:67%;" />

## HashMap为什么线程不安全？

![image-20240517124515426](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517124515426.png)



## `HashMap`和`HashTable`有何区别？

- `HashMap`：线程不安全的哈希表实现，允许键和值为`null`，效率高，适合单线程场景。
- `HashTable`：线程安全的哈希表实现，不允许键或值为`null`，通过`synchronized`实现同步，效率较低，适合多线程场景。



## ConcurrentHashMap和Hashtable的区别

![image-20240517130259268](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517130259268.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240517131046959.png" alt="image-20240517131046959" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523165745235.png" alt="image-20240523165745235" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523165826713.png" alt="image-20240523165826713" style="zoom:67%;" />



## ConcurrentHashMap 在性能方面做的优化

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240708194017817.png" alt="image-20240708194017817" style="zoom:67%;" />





# JVM篇

![image-20240520152244560](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520152244560.png)



## 什么是程序计数器？

程序计数器，记录的是正在执⾏的虚拟机字节码指令的地址。字节码解释器⼯作时，就是通过改变这个计数器的值来选取下⼀条需要执⾏的字节码指令，完成程序的流程控制。

另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

## 介绍一下java堆（对象实例、数组等

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520153419011.png" alt="image-20240520153419011" style="zoom:67%;" />

### **为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**

1.整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

2.元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。

3.永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

 

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520154001909.png" alt="image-20240520154001909" style="zoom:67%;" />

### 为什么年龄只能是 0-15？

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。不过，设置的值应该在 0-15

因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。

这里我们简单结合对象布局来详细介绍一下。

在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。其中，对象头包括两部分：标记字段（Mark Word）和类型指针（Klass Word）。关于对象内存布局的详细介绍，后文会介绍到，这里就不重复提了。

这个年龄信息就是在标记字段中存放的（标记字段还存放了对象自身的其他信息比如哈希码、锁状态信息等等）。



## 虚拟机栈（局部变量和方法调用

### 什么是虚拟机栈？

1.每个线程运行时所需要的内存，称为虚拟机栈

2.每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存

3.每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

4.栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。

5.它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。

### 垃圾回收是否涉及栈内存？

垃圾回收主要指就是堆内存，''当栈帧弹栈以后，内存就会释放

### 栈内存分配越大越好吗？

栈内存过大会导致线程数变少，因为你的系统内存是一定的；但栈内可容纳的栈帧就越多

### 方法内的局部变量是否线程安全？

如果方法内局部变量没有逃离方法的作用范围，它是线程安全的

如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

![image-20240520155706693](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520155706693.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520155718639.png" alt="image-20240520155718639" style="zoom:67%;" />

### 栈溢出和栈内存溢出

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520160629013.png" alt="image-20240520160629013" style="zoom:67%;" />



### 堆栈的不同

1.栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的。堆会GC垃圾回收，而栈不会。

2.栈内存是线程私有的，而堆内存是线程共有的。

3.两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。     

栈空间不足：java.lang.StackOverFlowError。     

堆空间不足：java.lang.OutOfMemoryError。

4.栈在编译时即可确定内存⼤⼩，堆是运⾏时确定内存⼤⼩



## 元空间/方法区（类信息、静态变量、常量、编译后的代码

### 解释一下方法区

方法区(Method Area)是各个线程共享的内存区域

主要存储**类的信息、运行时常量池**

虚拟机启动的时候创建，关闭虚拟机时释放

如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace

### 解释一下运行时常量池

常量池：可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息

当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240521145203167.png" alt="image-20240521145203167" style="zoom:67%;" />



### 你听过直接内存吗？（NIO不太懂

并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存

常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520162543382.png" alt="image-20240520162543382" style="zoom:50%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520162602977.png" alt="image-20240520162602977" style="zoom:50%;" />

## 类加载器

### 什么是类加载器？

JVM只会运行二进制文件，类加载器的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。

### 常见的类加载器有哪些？

启动类加载器(BootStrap ClassLoader):加载JAVA_HOME/jre/lib目录下的库

扩展类加载器(ExtClassLoader):主要加载JAVA_HOME/jre/lib/ext目录中的类

应用类加载器(AppClassLoader):用于加载classPath下的类

自定义类加载器(CustomizeClassLoader):自定义类继承ClassLoader，实现自定义类加载规则。

### 什么是双亲委派模型？

加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类

![image-20240520163533998](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520163533998.png)

### 双亲委派模型的执行流程

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240521160613365.png" alt="image-20240521160613365" style="zoom:80%;" />

**JVM 判定两个 Java 类是否相同的具体规则**：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 `Class` 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。



## 类装载的执行过程

![image-20240520165827908](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520165827908.png)



## JVM中的GC

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。



## 对象什么时候可以被GC？

如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。

如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法

### 引用计数法

一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收。当对象间出现了循环引用的话，则引用计数法就会失效

### 可达性分析

现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾。

Java  虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 扫描堆中的对象，看是否能够沿着 GC Root 对象 为起点的引用链找到该对象，找不到，表示可以回收。

**可作为GC Root的对象**

虚拟机栈(栈帧中的局部变量表)中引用的对象

本地方法栈(Native 方法)中引用的对象

方法区中类静态属性引用的对象

方法区中常量引用的对象

所有被同步锁持有的对象

JNI（Java Native Interface）引用的对象



## 引用类型总结

无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。

JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。

JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）

## 强引用 弱引用 软引用 虚引用

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520171147415.png" alt="image-20240520171147415" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520171223541.png" alt="image-20240520171223541" style="zoom:67%;" />

## JVM垃圾回收算法

1.标记清除算法：垃圾回收分为2个阶段，分别是标记和清除,效率高,有磁盘碎片，内存不连续

2.标记整理算法：标记清除算法一样，将存活对象都向内存另一端移动，然后清理边界以外的垃圾，无碎片，对象需要移动，效率低。老年代的GC常用

3.复制算法：将原有的内存空间一分为二，每次只用其中的一块,正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收;无碎片，内存使用率低。一般年轻代的GC使用

4.分代收集算法

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520171833514.png" alt="image-20240520171833514" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520173129138.png" alt="image-20240520173129138" style="zoom:67%;" />

## JVM中的垃圾回收器

**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**

在jvm中，实现了多种垃圾收集器，包括：

串行垃圾收集器：Serial GC（复制算法）、Serial Old （标记-整理算法）

GC并行垃圾收集器：ParNew GC（复制算法）、Parallel Old GC（标记-整理算法）

CMS（并发）垃圾收集器：CMS GC，作用在老年代（标记-清除算法）

G1垃圾收集器，作用在新生代和老年代

## 并行与并发

- **并行（Parallel）**：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。





## G1垃圾回收器（有点迷

### 流程

1.初始时，所有区域都处于空闲状态

2.创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象，JVM中新生代的内存不是固定的，在5%-6%之间波动，JVM会自动进行调整。因此伊甸园区是有限制的，我们不能随意创建对象。当伊甸园的数量够了之后，就会触发一次伊甸园的垃圾回收，采用复制算法，会用可达性分析算法表明哪些对象是存活下来的。没标记的就要被回收。

3.当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程（SWT

4.随着时间流逝，伊甸园的内存又有不足

5.将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代

6.当老年代占用内存超过阈值(默认是45%)后，触发**并发标记**，这时无需暂停用户线程(并发标记时无STW，并发标记后的重新标记需要STW

7.并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。

8.这些都完成后就知道了老年代有哪些存活对象，随后进入**混合收集阶段**。此时不会对所有老年代区域进行回收，而是根据暂停时间目标优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来），连同前面的伊甸园区和幸存者区一起回收。

9.混合收集阶段中，参与复制的有 eden、survivor、old

10.复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集

### 特点

![image-20240520175331310](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520175331310.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520175427716.png" alt="image-20240520175427716" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240521155542395.png" alt="image-20240521155542395" style="zoom:80%;" />



![image-20240613175602398](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613175602398.png)

![image-20240613175631083](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240613175631083.png)

### STW

[STW](https://so.csdn.net/so/search?q=STW&spm=1001.2101.3001.7020)，即`Stop-The-World`的缩写，指的是系统在执行特定操作时需暂停（停止）所有应用程序线程。



## 最常用的 JVM 参数配置

1.堆内存相关

1.1显式指定堆内存`–Xms`和`-Xmx`

-Xms<heap size>[unit]
-Xmx<heap size>[unit]

1.2显式新生代内存

-XX:NewSize=<young size>[unit]
-XX:MaxNewSize=<young size>[unit]

1.3显示指定永久代/元空间的大小

永久代

-XX:PermSize=N #方法区 (永久代) 初始大小
-XX:MaxPermSize=N #方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异

元空间

-XX:MetaspaceSize=N #设置 Metaspace 的初始大小（是一个常见的误区，后面会解释）
-XX:MaxMetaspaceSize=N #设置 Metaspace 的最大大小

2.垃圾回收器

-XX:+UseSerialGC
-XX:+UseParallelGC
-XX:+UseConcMarkSweepGC
-XX:+UseG1GC



## JVM调优参数在哪里设置？

1.war包部署在tomcat中设置：修改TOMCAT_HOME/bin/catalina.sh文件

2.jar包部署在启动参数设置：java -Xms512m -Xmx1024m -jar xxxx.jar

## JVM调优参数有哪些？

设置堆空间大小

年轻代中Eden区和两个Survivor区的大小比例

年轻代晋升老年代阈值

虚拟机栈的设置

设置垃圾回收收集器

## JVM调优工具有哪些？

**命令工具**

jps          进程状态信息

jstack     查看java进程内线程的堆栈信息

jmap      查看堆转信息（用于生成堆转内存快照、内存使用情况

jhat       堆转储快照分析工具

jstat      JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。

**可视化工具**

jconsole      用于对jvm的内存，线程，类 的监控

VisualVM    能够监控线程，内存情况（只有jdk1.8中有，高版本的默认没u偶，要使用的话需要到官网去下载

## JAVA内存泄露的排查思路

![image-20240520185449419](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240520185449419.png)

内存泄露通常是指堆内存，通常是指一些大对象不被回收的情况

1、通过jmap或设置jvm参数获取堆内存快照dump

2、通过工具， VisualVM去分析dump文件，VisualVM可以加载离线的dump文件

3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题

4、找到对应的代码，通过阅读上下文的情况，进行修复即可

## CPU飙高排查方案与思路

1.使用top命令查看占用cpu的情况, 通过top命令查看后，可以查看是进程40940中占用cpu较高

2.查看该进程中的线程信息，通过以上分析，在进程40940中的线程40950占用cpu较高

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240421160100681.png" alt="image-20240421160100681" style="zoom:50%;" />

3.可以根据线程 id 找到有问题的线程，进一步定位到问题代码的源码行号（这一步还包含了一个十进制转十六进制的问题

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240421160246825.png" alt="image-20240421160246825" style="zoom:50%;" />

4.查看这个线程中的代码   ---》 发现第9行处有一个while(true)死循环



## HotSpot虚拟机

### 对象的创建

1.类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

2.分配内存

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**内存分配的两种方式** （补充内容，需要掌握）：

- 指针碰撞： 
  - 适用场合：堆内存规整（即没有内存碎片）的情况下。
  - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
  - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表： 
  - 适用场合：堆内存不规整的情况下。
  - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
  - 使用该分配方式的 GC 收集器：CMS

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

3.初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值

4.设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5.执行init方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 对象的内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头（Header）**、**实例数据（Instance Data）\**和\**对齐填充（Padding）**。

对象头包括两部分信息：

1. 标记字段（Mark Word）：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。
2. 类型指针（Klass Word）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。（这个类的成员变量）

**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522171839226.png" alt="image-20240522171839226" style="zoom:67%;" />

### 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**、**直接指针**。

**使用句柄**

如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

**直接指针**

如果使用直接指针访问，reference 中存储的直接就是对象的地址。

这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。





# 并发编程

## JAVA并发包组件了解多少？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240530222052689.png" alt="image-20240530222052689" style="zoom:50%;" />

外层框架主要有Lock(ReentrantLock、ReadWriteLock等)、同步器（semaphores等）、阻塞队列（BlockingQueue等）、Executor（线程池）、并发容器（ConcurrentHashMap等）、还有Fork/Join框架；
内层有AQS（AbstractQueuedSynchronizer类，锁功能都由他实现）、非阻塞数据结构、原子变量类(AtomicInteger等无锁线程安全类)三种。
底层就实现是volatile和CAS。整个并发包其实都是由这两种思想构成的。

## 线程和进程的区别

一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)\**资源，但是每个线程有自己的\**程序计数器**、**虚拟机栈** 和 **本地方法栈**。

**总结：** **线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523151833587.png" alt="image-20240523151833587" style="zoom:67%;" />

## 并行与并发的区别

- **并发**：两个及两个以上的作业在同一 **时间段** 内执行。
- **并行**：两个及两个以上的作业在同一 **时刻** 执行。

## 同步和异步的区别

- **同步**：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
- **异步**：调用在发出之后，不用等待返回结果，该调用直接返回。

## 使用多线程可能带来哪些问题？

并发编程的目的就是为了能提高程序的执行效率进而提高程序的运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等

## 创建线程的方式有哪些？

共有四种方式可以创建线程，分别是：

继承Thread类

实现runnable接口

实现Callable接口

线程池创建线程

不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。严格来说，Java 就只有一种方式可以创建线程，那就是通过`new Thread().start()`创建。不管是哪种方式，最终还是依赖于`new Thread().start()`。



### 使用runnable和callable都可以创建线程，它们有什么区别呢？

1.Runnable 接口run方法没有返回值

2.Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果

3.Runnable接口的run()方法的异常只能在内部消化，不能继续上抛； Callable接口的call()方法允许抛出异常；

![image-20240522154237782](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522154237782.png)

### 在启动线程的时候，可以使用run方法吗？run()和 start()有什么区别？

New 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行**



![image-20240522154654772](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522154654772.png)

## 线程包括哪些状态？状态之间是如何变化的？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522154904888.png" alt="image-20240522154904888" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522155241720.png" alt="image-20240522155241720" style="zoom:67%;" />

## 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522155722059.png" alt="image-20240522155722059" style="zoom:67%;" />

## notify()和 notifyAll()有什么区别？

notifyAll：唤醒所有wait的线程

notify：只随机唤醒一个 wait 线程

## java中wait和sleep方法的不同？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523152808613.png" alt="image-20240523152808613" style="zoom:67%;" />

## 如何停止一个正在运行的线程？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522162032743.png" alt="image-20240522162032743" style="zoom:67%;" />

线程处于阻塞状态：

例如：在使用 sleep、调用锁的 wait 或者调用 socket 的 receive、accept 等方法的时候，会使线程处于阻塞状态。**在调用线程的 interrupt 方法时，会抛出 InterruptException 异常，我们通过在代码中捕获异常，然后通过 break 跳出状态监测循环，结束这个线程的执行。**通常很多人认为只要调用 interrupt 方法就会结束线程，这个理解其实是有问题的，一定是要先捕获 InterruptedException 异常后再通过 break 跳出循环，才能正常的结束 run 方法。

线程处于未阻塞状态

在这个时候，使用 isInterrupted 方法判断线程的中断标志来退出循环。**在调用 interrupt 方法的时候，中断标志会设置为 true**，此时并不能立刻退出线程而是需要执行线程终止前的资源释放操作，等待资源释放完毕后方可安全退出该线程。



## 乐观锁和悲观锁

1.当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。
2.当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。
————————————————

### 乐观锁实现

乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，

#### 版本号机制

一般是在数据表中加上一个数据版本号 `version` 字段，表示数据被修改的次数。当数据被修改时，`version` 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 `version` 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 `version` 值相等时才更新，否则重试更新操作，直到更新成功。

#### CAS算法

CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。

CAS使用到的地方很多：AQS框架、AtomicXXX类, JDK1.8的ConcurrentHashMap

在操作共享变量的时候使用的自旋锁，效率上更高一些

CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现

#### CAS算法存在的问题

1.ABA问题

如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 **"ABA"问题。**

ABA 问题的解决思路是在变量前面追加上**版本号或者时间戳**。JDK 1.5 以后的 `AtomicStampedReference` 类就是用来解决 ABA 问题的，其中的 `compareAndSet()` 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

2.循环开销时间大

CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。

### 悲观锁

悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**。

像 Java 中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现

高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。





## synchronized关键字的底层原理

1.Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】

2.它的底层由monitor实现的，monitor是jvm级别的对象（ C++实现），线程获得锁需要使用对象（锁）关联monitor

3.在monitor内部有三个属性，分别是owner、entrylist、waitset

4.其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程

**扩展**

synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。

不过，在 Java 6 之后， synchronized 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 synchronized 锁的效率提升了很多。因此， synchronized 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 synchronized 。

## synchronized关键字的底层原理--进阶

### Monitor重量级锁，对象怎么关联上的Monitor的

在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充。在对象头的MarkWord中记录了monitor的地址，对象就可以与monitor进行关联

![image-20240522172248250](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522172248250.png)



### 轻量级锁

![image-20240522172937394](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522172937394.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522173009489.png" alt="image-20240522173009489" style="zoom:67%;" />

### 偏向锁

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522173456721.png" alt="image-20240522173456721" style="zoom:80%;" />

### 讲一下synchronized中的锁升级

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522173841623.png" alt="image-20240522173841623" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522174958313.png" alt="image-20240522174958313" style="zoom:67%;" />

锁升级是针对于synchronized锁在不同竞争条件下的一种优化，根据锁在多线程中竞争的程度和状态，synchronized锁可在无锁、偏向锁、轻量级锁和重量级锁之间进行流转，以降低获取锁的成本，提高获取锁的性能。

1.当一个共享资源首次被某个线程访问时，锁就会从无锁状态升级到偏向锁状态，偏向锁会在Markword的偏向线程ID里存储当前线程的操作系统线程ID，偏向锁标识位是1，锁标识位是01。此后如果当前线程再次进入临界区域时，只比较这个偏向线程ID即可，这种情况是在只有一个线程访问的情况下，不再需要操作系统的重量级锁来切换上下文，提供程序的访问效率。

2.如果未开启偏向锁（或者在JVM偏向锁延迟时间之前），有线程访问共享资源则直接由无锁升级为轻量级锁，开启偏向线程锁后，并且当前共享资源锁已经是偏向锁时，再有第二个线程访问共享资源锁时，此时锁可能升级为轻量级锁，也可能还是偏向锁状态，因为这取决于线程间的竞争情况，如有没有竞争，那么偏向锁的效率更高（因为频繁的锁竞争会导致偏向锁的撤销和升级到轻量级锁），继续保持偏向锁。如果有竞争，则锁状态会从偏向锁升级到轻量级锁，这种情况下轻量级锁效率会更高。

3.轻量级锁是在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象头的Markword到栈帧的Lock Record，若拷贝成功，JVM将使用CAS操作尝试将对象头的Markword更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象头的Markword。若拷贝失败,若当前只有一个等待线程，则可通过自旋继续尝试， 当自旋超过一定的次数，或者一个线程在持有锁，一个线程在自旋，又有第三个线程来访问时，轻量级锁就会膨胀为重量级锁。

4.当轻量级锁获取锁失败时，说明有竞争存在，轻量级锁会升级为重量级锁，此时，JVM会将线程阻塞，直到获取到锁后才能进入临界区域，底层是通过操作系统的mutex lock来实现的，每个对象指向一个monitor对象，这个monitor对象在堆中与锁是关联的，通过monitorenter指令插入到同步代码块在编译后的开始位置，monitorexit指令插入到同步代码块的结束处和异常处，这两个指令配对出现。JVM的线程和操作系统的线程是对应的，重量级锁的Markword里存储的指针是这个monitor对象的地址，操作系统来控制内核态中的线程的阻塞和恢复，从而达到JVM线程的阻塞和恢复，涉及内核态和用户态的切换，影响性能，所以叫重量级锁。

## 你谈谈 JMM（Java内存模型）（具体看javaguide

JMM(Java Memory Model)Java内存模型，定义了共享内存中多线程程序读写操作的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性

JMM把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存

## 谈谈你对 volatile 的理解

①保证线程间的可见性

用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见

② 禁止进行指令重排序

指令重排：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240522184524126.png" alt="image-20240522184524126" style="zoom:80%;" />



另外， **`volatile` 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。**

## 什么是AQS？

全称是 AbstractQueuedSynchronizer，即抽象队列同步器

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523155625842.png" alt="image-20240523155625842" style="zoom:80%;" />

## ReentrantLock的实现原理

`ReentrantLock` 实现了 `Lock` 接口，是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能

ReentrantLock主要利用CAS+AQS队列来实现

支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁



## synchronized和Lock有什么区别 ? 

synchronized 是一个 关键字，使用C++实现的，没办法控制锁的开始、锁结束，也没办法中断线程的执行

而 lock 是 java层面的实现，可以获取锁的状态，开启锁，释放锁，通过设置可以中断线程的执行，更加灵活

是否自动释放锁：synchronized 会自动释放锁，而 lock 需要手动调用unlock 方法释放，否则会死循环
————————————————

1.synchronized 是一个 关键字，使用C++实现的；而 lock 是 java层面的实现

2.synchronized 没办法控制锁的开始、锁结束；而 lock可以获取锁的状态，开启锁，释放锁，通过设置可以中断线程的执行

3.synchronized 会自动释放锁，而 lock 需要手动调用unlock 方法释放，否则会死循环

4.二者都属于悲观锁，都具备基本的互斥、同步、锁重入功能；Lock提供了许多synchronized 不具备的功能，比如公平锁，可打断





<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523161004253.png" alt="image-20240523161004253" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523161711671.png" alt="image-20240523161711671" style="zoom:67%;" />

**可中断锁**：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。`ReentrantLock` 就属于是可中断锁。

**不可中断锁**：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 `synchronized` 就属于是不可中断锁。

## 死锁问题

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。

### 死锁产生的条件是什么？（4个必要条件

1.互斥条件：该资源任意一个时刻只由一个线程占用。

2.请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。

3.不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。

4.循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。

### 如何进行死锁诊断？

当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack

jps：输出JVM中运行的进程状态信息

jstack：查看java进程内线程的堆栈信息，查看日志，检查是否有死锁     如果有死锁现象，需要查看具体代码分析后，可修复

可视化工具jconsole、VisualVM也可以检查死锁问题

### 如何预防死锁？

1.**破坏请求与保持条件**：一次性申请所有的资源。

2.**破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

**3.破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。



## Java程序中怎么保证多线程的执行安全(导致并发程序出现问题的根本原因是什么)

多个线程同时操作一个共享变量时，这其中就涉及到线程安全问题 

http://t.csdnimg.cn/7XsPI

Java并发编程三大特性:原子性、可见性、有序性 未得到满足。

1.原子性     synchronized、lock

2.内存可见性   volatile、synchronized、lock

3.有序性     volatile

![image-20240620195300330](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240620195300330.png)

## 线程池

### 为什么要使用线程池？

**降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

**提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。

**提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控

在实际应用中，选择**合适的线程池大小**需要考虑系统的负载情况、任务执行时间和资源消耗等因素。通常需要通过压测和监控来调整线程池的参数，以达到最优的性能和资源利用率。

### 线程池的核心参数

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523170614259.png" alt="image-20240523170614259" style="zoom:50%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523170830020.png" alt="image-20240523170830020" style="zoom:67%;" />

### 线程池的执行原理知道吗？

![image-20240523171136569](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523171136569.png)

### 线程池中有哪些常见的阻塞队列

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523171435977.png" alt="image-20240523171435977" style="zoom:67%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523171557876.png" alt="image-20240523171557876" style="zoom:67%;" />

### 如何确定核心线程数？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523171742030.png" alt="image-20240523171742030" style="zoom:80%;" />



### 创建线程池的方式

**方式一：通过`ThreadPoolExecutor`构造函数来创建（推荐）。**

**方式二：通过 `Executor` 框架的工具类 `Executors` 来创建。**



### 线程池的种类有哪些？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523172515722.png" alt="image-20240523172515722" style="zoom:80%;" />

### 为什么不建议用Executors创建线程池

![image-20240612182427952](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240612182427952.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523173244219.png" alt="image-20240523173244219" style="zoom:80%;" />

## 线程池使用场景（CountDownLatch、Future）你们项目哪里用到了多线程）

### 使用场景1（黑马头条的导入ES优化

![image-20240523180850488](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523180850488.png)

![image-20240523180924129](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523180924129.png)

![image-20240523180950534](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523180950534.png)

### 使用场景2（多表汇总

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523181816202.png" alt="image-20240523181816202" style="zoom:80%;" />

### 使用场景3（黑马头条的异步保存搜索记录

![image-20240523182900750](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523182900750.png)





## 如何控制某个方法允许并发访问线程的数量

在多线程中提供了一个工具类Semaphore，信号量，是JUC包下的一个工具类，底层是AQS，我们可以通过其限制执行的线程数量。在并发的情况下，可以控制方法的访问量。通常用于那些资源有明确访问数量限制的场景，常用于限流 。

1.创建Semaphore对象，可以给一个容量

2.acquire()可以请求一个信号量，这时候的信号量个数-1

3.release()释放一个信号量，此时信号量个数+1

## ThreadLocal的底层原理及内存泄露问题

![image-20240523191120839](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240523191120839.png)



## Atomic原子类介绍

Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 **Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰**。所以，所谓原子类说简单点就是具有原子/原子操作特征的类。

并发包 `java.util.concurrent` 的原子类都存放在`java.util.concurrent.atomic`

### AtomicInteger

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606202315645.png" alt="image-20240606202315645" style="zoom:67%;" />

![image-20240606202343760](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606202343760.png)



# MYSQL篇

## 如何定位慢查询？

1.我们系统中当时采用了运维工具（ Skywalking ），可以监测出哪个接口，最终因为是sql的问题

2.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中（调试阶段）

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525140900523.png" alt="image-20240525140900523" style="zoom:67%;" />

## 一个SQL语句执行很慢, 如何分析

可以采用EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525141404420.png" alt="image-20240525141404420" style="zoom:67%;" />

可以采用MySQL自带的分析工具 EXPLAIN

1.通过key和key_len检查是否命中了索引（索引本身存在是否有失效的情况）

2.通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描

通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复



## MYSQL支持的存储引擎有哪些,？

存储引擎：就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。

| **特性** | **MyISAM** | **InnoDB**            | **MEMORY** |
| -------- | ---------- | --------------------- | ---------- |
| 事务安全 | 不支持     | **支持**              | 不支持     |
| 锁机制   | 表锁       | **表锁****/****行锁** | 表锁       |
| 外键     | 不支持     | **支持**              | 不支持     |



## MYSQL体系结构

![image-20240525142335297](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525142335297.png)

## InnoDB存储引擎的特点

InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。

**特点** 

DML操作遵循ACID模型，支持事务

行级锁，提高并发访问性能 

支持外键FOREIGN KEY约束，保证数据的完整性和正确性

**文件**	

xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。 

xxx.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）

## 索引

### 什么是索引？

索引（index）是帮助MySQL高效获取数据的数据结构(有序)

提高数据检索的效率，降低数据库的IO成本（不需要全表扫描）

通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗

### 索引优缺点

**优点**：

- 使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

**缺点**：

- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。

### 索引底层数据结构

MySQL默认使用的索引底层数据结构是B+树

B树与B+树对比:①：磁盘读写代价B+树更低；②：查询效率B+树更加稳定；③：B+树便于扫库和区间查询

### 选B+树的原因

**为什么 MySQL 没有使用Hash作为索引的数据结构呢？** 主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。

**二叉查找树**的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。

**AVL 树**需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 **磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。

和 AVL 树不同的是，**红黑树**并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。也正因如此，红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。

**红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。**



### 索引分类

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240527155041416.png" alt="image-20240527155041416" style="zoom:67%;" />

唯一索引，普通索引，前缀索引等索引都属于二级索引。

#### 聚集索引和二级索引

| 分类                      | 含义                                                       | 特点                |
| ------------------------- | ---------------------------------------------------------- | ------------------- |
| 聚集索引(Clustered Index) | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有,而且只有一个 |
| 二级索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个        |

通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表

#### 覆盖索引

覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到 

使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。

如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *

#### MYSQL超大分页（深度分页）处理

![image-20240525145318160](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525145318160.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525145434330.png" alt="image-20240525145434330" style="zoom:67%;" />



### 索引创建原则

![image-20240525145719847](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525145719847.png)

### 索引失效的场景

违反最左前缀法则

范围查询右边的列，不能使用索引

不要在索引列上进行运算操作， 索引将失效

字符串不加单引号，造成索引失效。(类型转换)

以%开头的Like模糊查询，索引失效



### 谈谈你对sql的优化的经验

1.表的设计优化，数据类型的选择

2.索引优化，参考索引创建原则

3.sql语句优化，避免索引失效，避免使用select *  ….

4.主从复制、读写分离，不让数据的写入，影响读操作

5.分库分表

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525150542626.png" alt="image-20240525150542626" style="zoom:67%;" />

## 事务

事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

### 事务四大特性

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525151402560.png" alt="image-20240525151402560" style="zoom:67%;" />

### 并发事务问题

脏读、不可重复读、幻读

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525152138989.png" alt="image-20240525152138989" style="zoom:80%;" />

### 事务隔离级别

如何解决并发事务问题呢？   解决方案：对事务进行隔离

![image-20240525152325518](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525152325518.png)

**READ-UNCOMMITTED(读取未提交)** ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

**READ-COMMITTED(读取已提交)** ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

**REPEATABLE-READ(可重复读)** ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

**SERIALIZABLE(可串行化)** ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。



### undo log和redo log和bin log

#### **redo log**



<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525153943621.png" alt="image-20240525153943621" style="zoom:50%;" />

![image-20240525154344568](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525154344568.png)



现在我们来思考一个问题：**只要每次把修改后的数据页直接刷盘不就好了，还有 redo log 什么事？**

实际上，数据页大小是`16KB`，刷盘比较耗时，可能就修改了数据页里的几 `Byte` 数据，有必要把完整的数据页刷盘吗？

而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。

如果是写 redo log，一行记录可能就占几十 `Byte`，只包含表空间号、数据页号、磁盘文件偏移量、更新值，再加上是顺序写，所以刷盘速度很快。

所以用 redo log 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。



#### undo log

![image-20240525154410318](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525154410318.png)

redo log: 记录的是数据页的物理变化，服务宕机可用来同步数据

undo log ：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据

redo log保证了事务的持久性，undo log保证了事务的原子性和一致性(隔离性通过锁或者MVCC保证)



[三者区别](https://blog.csdn.net/yxg520s/article/details/122242793?ops_request_misc=&request_id=&biz_id=102&utm_term=bin%20log&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-122242793.142^v100^pc_search_result_base3&spm=1018.2226.3001.4187)



### 并发事务的控制方式有哪些？

锁和MVCC

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240527161934138.png" alt="image-20240527161934138" style="zoom:80%;" />

**MVCC** 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。

### MVCC

![image-20240525161926541](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525161926541.png)

### 快照读和当前读（不太理解

![image-20240525163443339](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525163443339.png)



### MySQL 的隔离级别是基于什么实现的？

基于锁和 MVCC 机制共同实现的。

SERIALIZABLE 隔离级别是通过锁来实现的

READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。

不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。



### 数据库是如何解决幻读的？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240527175703935.png" alt="image-20240527175703935" style="zoom:67%;" />

MySQL在**可重复读**隔离级别下，是通过MVCC机制避免幻读的。

**1.普通读（快照读）解决幻读问题**

MySQL在可重复读隔离级别下，是通过MVCC机制避免幻读的。

MVCC机制，可以简单理解成在事务启动的时候对数据库拍了个“快照”，它保留了那个时刻数据库的数据状态，那么这个事务后续的读取都可以从这个“快照”中获取，哪怕其他事务新加了数据，也不会影响到“快照”中的数据，也就不会出现幻读了

**2.当前读解决幻读问题**

也就是说不能读取“**快照**”了，因为你要最新状态的数据，那么能不能在当前读的时候，对这段区间都加上锁，让别的事务阻塞，无法插入。因此，MySQL`InnoDB`引擎为了解决可重复读隔离级别使用当前读而造成的幻读问题，引入了**间隙锁**。

**3.总结**

MySQL默认采用的隔离级别是可重复读，在这种隔离级别下不同的读模式，针对幻读问题采用了不同解决方案：

针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。
针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。



## MYSQL主从同步

![image-20240525164334531](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525164334531.png)

从库的 SQL 线程读取 relay log 同步数据到本地（也就是再执行一遍 SQL ）。

**拓展**

不知道大家有没有使用过阿里开源的一个叫做 canal 的工具。这个工具可以帮助我们实现 MySQL 和其他数据源比如 Elasticsearch 或者另外一台 MySQL 数据库之间的数据同步。很显然，这个工具的底层原理肯定也是依赖 binlog。canal 的原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。

另外，像咱们常用的分布式缓存组件 Redis 也是通过主从复制实现的读写分离。

总的来说，要想不出现数据库主从延迟问题，一般还是要强制将那些必须获取最新数据的读请求都交给主库处理。

**MySQL 主从同步延时**

MySQL 主从同步延时是指从库的数据落后于主库的数据，这种情况可能由以下两个原因造成：

1. 从库 I/O 线程接收 binlog 的速度跟不上主库写入 binlog 的速度，导致从库 relay log 的数据滞后于主库 binlog 的数据；
2. 从库 SQL 线程执行 relay log 的速度跟不上从库 I/O 线程接收 binlog 的速度，导致从库的数据滞后于从库 relay log 的数据。



## 分库分表

1，水平分库，将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题

2，水平分表，解决单表存储和性能的问题

3，垂直分库，根据业务进行拆分，高并发下提高磁盘IO和网络连接数

4，垂直分表，冷热数据分离，多表互不影响

**分库分表会带来什么问题呢？**

![image-20240527170457874](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240527170457874.png)

**总结**

![image-20240527170607658](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240527170607658.png)



## MYSQL中的锁

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525170404147.png" alt="image-20240525170404147" style="zoom:50%;" />

InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 `UPDATE`、`DELETE` 语句时，如果 `WHERE`条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240527163156714.png" alt="image-20240527163156714" style="zoom:67%;" />





## MySQL体系结构

![image-20240525170325002](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525170325002.png)

## 一条SQL的内部执行流程

查询语句

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240525170240253.png" alt="image-20240525170240253" style="zoom:67%;" />

更新语句

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240527152022786.png" alt="image-20240527152022786" style="zoom:67%;" />

总结

![image-20240527152534428](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240527152534428.png)



# JAVA基础篇

## 面向对象和面向过程

**面向过程**：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一 一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发

**面向对象**：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有**封装、继承、多态**的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。



## 面向对象三大特征

**封装**

封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

**继承**

继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被 称为父类（超类、基类） ；

得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性 ，同时继承也是封装程序中可变因素的重要手段

**关于继承如下 3 点请记住：**

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。（以后介绍）。

**多态**

多态性是指允许不同子类型的对象对同一消息作出不同的响应。 简单地说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分 为编译时的多态性和运行时的多态性。方法重载（ overload）实现的是编译时的多态性（也称为前绑定），而方法重写（ override ） 实现的是运行时的多态性（也称为后绑定）。

运行时的多态是面向对象最精髓的 东西 ，要实现多态需要做两件事 ：

1). 方法重写（子类继承父类并重写父类中已 有的或抽象的方法） ；

2). 对象造型（用父类型引用子类型对象 ，这样同样 的引用调用同样的方法就会根据子类对象的不

同而表现出不同的行为）。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604201209296.png" alt="image-20240604201209296" style="zoom:67%;" />

## **继承（Inheritance）和多态（Polymorphism）的区别是什么？它们分别如何实现？**

- **回答：** 继承是指一个类（子类）可以继承另一个类（父类）的属性和方法，使得子类可以复用父类的代码。多态是指同一个方法在不同对象上具有不同的行为表现形式。继承通过extends关键字实现，而多态通过方法的重写（Override）和方法的重载（Overload）来实现。



## 接口和抽象类

1.抽象类中的方法可以有方法体，能实现方法具体要实现的功能，但是接口中的方法不行，没有方法体。
2.抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的，并且是隐式的，缺省的。
3.接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法的。
4.一个类只能继承一个抽象类，而一个类却可以实现多个接口。
5.抽象类体现了数据抽象的思想（不然呢），是实现多态的一种机制。抽象类定义了一组抽象的方法，至于这组抽象方法的具体表现形式由子类来继承实现。抽象类就是用来继承的，否则它就没有存在的任何意义。

接口是一种比抽象类更加抽象的“类”，毕竟是用关键字 interface 声明的，不是用 class。

接口只是一种形式，就好像一纸契约，自身不能做任何事情。但只要某个类实现了这个接口，就必须按照这纸契约来办事：接口里提到的方法必须全部实现，少一个都不行（抽象类的子类可以忽视非抽象方法）

![image-20240604205409718](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604205409718.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604205450037.png" alt="image-20240604205450037" style="zoom:67%;" />





## JAVA自动装箱与自动拆箱

![image-20240604182402255](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604182402255.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604182251177.png" alt="image-20240604182251177" style="zoom:67%;" />

享元模式是一种结构型的设计模式。它的主要目的是通过共享对象来减少系统中对象的数量，**其本质就是缓存共享对象，降低内存消耗**。

Integer 内部用到了享元模式的设计，针对-128 到 127 之间的数字做了缓存。

在通过 valueOf 方法创建 Integer 对象的时候，如果数值在[-128,127]之间，便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象。

上面的代码中 i1 和 i2 的数值为 100，因此会直接从 cache 中取已经存在的对象，所以 i1 和 i2

指向的是 同一个对象，而 i3 和 i4 则是分别指向不同的对象。

![image-20240606143819908](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606143819908.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604185120112.png" alt="image-20240604185120112" style="zoom:67%;" />

## 重写与重载的区别

**重载**

发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。

**重写**

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

综上：**重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604193523337.png" alt="image-20240604193523337" style="zoom:67%;" />

## 浅拷贝 深拷贝 引用拷贝

**浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。

**深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

**那什么是引用拷贝呢？** 简单来说，引用拷贝就是两个不同的引用指向同一个对象。

![image-20240604210041896](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604210041896.png)

## == 和 equals 的区别

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604210531034.png" alt="image-20240604210531034" style="zoom:67%;" />



## Java基本数据类型

![image-20240618224734581](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240618224734581.png)

注意：**基本数据类型存放在栈中是一个常见的误区！** 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。





## **为什么浮点数 `float` 或 `double` 运算的时候会有精度丢失的风险呢？**







## String为什么是不可变的？

1.保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。

2.`String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

![image-20240604211744089](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604211744089.png)

在 Java 9 之后，`String`、`StringBuilder` 与 `StringBuffer` 的实现改用 `byte` 数组存储字符串。

![image-20240604211935133](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604211935133.png)



## String s1 = new String("abc");这句话创建了几个字符串对象？

会创建 1 或 2 个字符串对象。

1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。

2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。

String s = new String("abc");语句，如果这里"abc"本身就是pool中的一个对象，而在运行时执行new String()时，将pool中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给s持有。ok，这条语句就创建了2个String对象。

## String.intern()方法有什么作用？

![image-20240606173925768](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606173925768.png)



## Java异常

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604214507465.png" alt="image-20240604214507465" style="zoom:80%;" />

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240604214530521.png" alt="image-20240604214530521" style="zoom:80%;" />

## try-catch-finally 中finally中代码一定会执行吗？

不一定

1.finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。

2.程序所在的线程死亡。

3.关闭 CPU。



## 泛型

### 泛型特点及好处

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240605154614451.png" alt="image-20240605154614451" style="zoom:50%;" />

### 泛型擦除

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240605162036512.png" alt="image-20240605162036512" style="zoom:67%;" />

### 泛型通配符

1.<?>

2.<? extends T>表示该通配符所代表的类型是 T 类型的子类。

3.<? super T>表示该通配符所代表的类型是 T 类型的父类。

**在现实编码中，确实有这样的需求，希望泛型能够处理`某一类型范围内`的类型参数，比如某个泛型类和它的子类，为此 Java 引入了`泛型通配符`这个概念。**

类SuperA是类A的父类，则G<SuperA>与 G<A>的关系:G<SuperA>和 G<A>是并列的两个类，没有任何子父类的关系比如:ArrayList<0bject>、ArrayList<string>没有关系

在引入泛型通配符之后，我们便得到了一个在`逻辑上`可以表示为某一类型参数范围的父类引用类型。举例来说，泛型通配符可以表示 Pair< Integer > 和 Pair< Number > 两者的`父类引用类型`。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240605162538300.png" alt="image-20240605162538300" style="zoom:50%;" />

## 反射

### 什么是反射？

在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。

### 反射的优缺点

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240605164402113.png" alt="image-20240605164402113" style="zoom:67%;" />

![image-20240605165639417](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240605165639417.png)



### 反射中获取class对象的方式

有 4 种方法： 

1 ）Class.forName(“类的路径”） ；2）类名.class 3）

对象 名.getClass() 4）基本类型的包装类，可以调用包装类的 Type 属性来获得该包装类的 Class对象

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240605165034156.png" alt="image-20240605165034156" style="zoom:67%;" />

### 实现java反射的类（java反射API

1 ）Class：表示正在运行的 Java 应用程序中的类和接口 注意： 所有获取对象的信息都需要 Class类 来实现。 

2 ）Field：提供有关类和接口的属性信息，以及对它的动态访问权限。 

3 ）Constructor： 提供关于类的单个构造方法的信息以及它的访问权限 

4 ）Method：提供类或接口中某个方法的信息

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240605165423432.png" alt="image-20240605165423432" style="zoom:50%;" />



### 反射使用步骤

（获取 Class 对象、调用对象方法）

\1. 获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方 法。

\2. 调用 Class 类中的方法，既就是反射的使用阶段。

\3. 使用反射 API 来操作这些信息。



### 反射使用场景（需进一步理解

反射机制允许在运行时加载和使用类，可以动态的调用该类的属性和方法，可以绕过 Java 的访问控制检查，访问和修改私有字段和方法。

1.像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。

**这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。**

比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 `Method` 来调用指定的方法。

2.像 Java 中的一大利器 **注解** 的实现也用到了反射。

为什么你使用 Spring 的时候 ，一个`@Component`注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 `@Value`注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？

这些都是因为你可以基于反射分析类，然后获取到类/属性/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。

### 使用反射机制和普通的创建对象有何区别？

反射操作通常比直接代码调用要慢，因为它需要进行安全检查和类型转换。但是反射提供了对类的结构化访问，可以动态地调用和修改现有类的方法和字段，灵活性更强。反射适用于需要在运行时动态操作现有类和对象的场景，而普通创建对象适用于需要在运行时编写和执行新代码的场景。

普通的对象创建通常是在编译时确定的，例如通过类的构造函数直接实例化对象。而使用反射机制，可以在运行时通过类的全限定名或者类对象来动态地获取类的信息，并实例化对象。这种方式允许在运行时动态地加载、检查和操作类，从而实现更灵活的程序设计。

## 注解

### 注解的解析方法有哪几种？

注解只有被解析之后才会生效，常见的解析方法有两种：

- **编译期直接扫描**：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过反射来进行处理的。

### 元注解

元注解是什么意思呢？

元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。

如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。

元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。

##### @Retention 

Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的存活时间。我们可以这样的方式来加深理解，@Retention 去给一张标签解释的时候，它指定了这张标签张贴的时间。@Retention 相当于给一张标签上面盖了一张时间戳，时间戳指明了标签张贴的时间周期。

##### @Documented

顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。

##### @Target

Target 是目标的意思，@Target 指定了注解运用的地方。

你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。

类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值

##### @Inherited

Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。 

##### @Repeatable

Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。

@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。

### 常见注解

##### @Deprecated

这个元素是用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量

##### @Override

这个大家应该很熟悉了，提示子类要复写父类中被 @Override 修饰的方法

##### @Test 

标记了要进行测试的方法 addition_isCorrect().

### 注解的获取

注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解

然后通过 getAnnotation() 方法来获取 Annotation 对象。

或者是 getAnnotations() 方法。



## 序列化和反序列化

- **序列化**：将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240605180328873.png" alt="image-20240605180328873" style="zoom:80%;" />

### 常见应用场景

1.对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；

2.将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；

3.将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；

4.将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。

### Java中如何实现序列化？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240605180713848.png" alt="image-20240605180713848" style="zoom:80%;" />

### **序列化协议对应于 TCP/IP 4 层模型的哪一层？**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240605180934594.png" alt="image-20240605180934594" style="zoom:80%;" />

## I/O（单独抽空看

## 语法糖

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240605181857165.png" alt="image-20240605181857165" style="zoom:80%;" />

## JAVA代理模式（看javaguide

**反射是什么**
Java反射机制是一种在程序运行时检查、获取和操作类、接口、方法、字段等元数据信息的机制。通过反射机制，可以在运行时动态地创建对象、调用方法、获取和修改对象的属性等。

**动态代理是什么？**
动态代理是一种在运行时动态创建代理对象的机制。它可以让程序在运行时动态地将方法调用分配给不同的实现类，从而实现各种功能的扩展和增强。

因此可以说动态代理是依赖于反射而实现的功能，动态代理也可以说是一个代理机制，可以看作是装饰器（ Decorator）模式的应用，通过代理可以让调用者与实现者之间解耦。

当使用Java动态代理时，需要提供一个实现了指定接口的委托对象，然后使用Proxy.newProxyInstance()方法动态生成一个代理对象。该方法的第一个参数是一个ClassLoader对象，用于加载生成的代理类；第二个参数是一个Class数组，其中包含需要实现的接口；第三个参数是一个InvocationHandler对象，用于处理代理对象的方法调用。

InvocationHandler接口中定义了一个invoke()方法，用于处理代理对象的方法调用。在invoke()方法中，通过反射机制获取被代理方法的信息，并将方法调用转发给委托对象。
————————————————

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606190718924.png" alt="image-20240606190718924" style="zoom:80%;" />



## JAVA值传递（看javaguide

**值传递**：方法接收的是实参值的拷贝，会创建副本。

**引用传递**：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。



如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。

如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。

