

目前八股主要以黑马为主，结合JavaGuide

Java基础部分看代码随想录

计算机基础部分看JvaGuide

# 单例模式

参考资料：[【单例模式】猛男因不懂单例模式，被面试官无情嘲讽_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1pt4y1X7kt/?spm_id_from=333.337.search-card.all.click&vd_source=2a200921c8b5d7294bdcf3ca4652bc6b)

[【狂神说Java】单例模式-23种设计模式系列_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1K54y197iS/?spm_id_from=333.337.search-card.all.click&vd_source=2a200921c8b5d7294bdcf3ca4652bc6b)

https://mp.weixin.qq.com/s/DIh68Sc8sjtrk-RLHdKjwQ

**单例模式：**
**单例模式是指在内存中只会创建且仅创建一次对象的设计模式。**在程序中**多次使用同一个对象且作用相同**时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中**创建一个对象**，让所有需要调用的地方都共享这一单例对象。

**创建单例模式应该考虑的3个点**

1. 是否是懒加载
1. 是否线程安全
1. 能否通过反射破坏
## 饿汉式（线程安全
```java
// 实现简单  线程安全  浪费资源
// 饿汉式：在类加载时已经创建好该单例对象，等待被程序使用
// 类在加载时会在堆内存中创建一个Singleton对象，当类被卸载时，Singleton对象也随之消亡了。
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() { }

    public static Singleton getInstance() {
        return instance;
    }
}
```
## 懒汉式（线程不安全

```java
// 懒汉式：在真正需要使用对象时才去创建该单例类对象
// 线程不安全，在多线程环境中不能使用该方式，只能在单线程环境中使用。
// 如果在多线程环境中，一个线程进入了 if (singleton == null)  判断语句块，还没往下执行，另一个线程也通过了这个判断语句，这时就会产生多个实例。
// 懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化（判空），若已实例化直接返回该类对象，否则先执行实例化操作。
public class Singleton {

     private static Singleton instance;

     private Singleton () { }

     public static Singleton getInstance ()  {  

         if (instance == null ) {  
             instance =  new Singleton  ( ) ;

         }
         return instance;

     }
}
```



## 双重检查锁（线程安全，又能懒加载

既能保证线程安全，又能懒加载

当多个线程进来getInstance() 后，如果实例对象还没有构建if (instance == null) ，则多个线程开始争抢锁synchronized (SingletonDCL.class)，抢到锁的线程开始实例化对象。但是此时有可能其他线程已经通过了第一层if (instance == null)判断进来等待，在抢到锁的对象完成实例化之后这个线程还可以继续获得锁完成实例化，因此要加第二层if (instance == null)判断，在其他线程获得锁后由于已经有线程完成了实例化，所以第二层if (instance == null)不满足，退出。

但是由于  **instance = new SingletonDCL();**不是一个原子性操作（1. 分配内存  2. 实例化对象  3. 对象指向内存地址），在真正执行时，虚拟机为了效率可能进行指令重排，一个线程可能会返回另一个线程未初始化的实例，因此要使用 volatile 关键字，来保证底层指令执行顺序。

入口处判断 null，可以省去每次加锁的耗费，提升性能。

但由于第一次加载反应稍慢，以及 Java 内存模型的原因，偶尔还是会失败，在高并发环境下存在一定的缺陷。

```java
   
public class Singleton {

    private volatile static Singleton instance = null;

    //构造方法私有

    private Singleton() {

    }

    public static Singleton getInstance() {

        //进行两次非空判断  ，第一层是为了避免不必要的同步

        if (instance == null) {

            //获取Singleton3.class的锁，避免实例化多次

            synchronized (Singleton.class) {

                if (instance == null) {

                    instance = new Singleton();

                }
            }
        }
        return instance;
    }
}
```



# JAVA静态方法和实例方法的区别

在Java中，静态方法（Static Method）和实例方法（Instance Method）有几个主要的区别，这些区别涉及到它们的调用方式、内存分配、以及对类和对象的依赖性。

1. 调用方式

- **静态方法**：通过类名直接调用，例如 `ClassName.staticMethod()`。
- **实例方法**：必须通过类的实例（对象）来调用，例如 `object.instanceMethod()`。

2. 内存分配

- **静态方法**：静态方法随着类的加载而加载，属于类级别的，只会在方法区（Method Area）中存储一份方法字节码，无需创建实例对象就可以调用。
- **实例方法**：实例方法在每个对象实例化时都会分配内存，即使是多个实例调用相同的实例方法，也会在堆内存中每个实例都保存一份方法代码。

3. 对象依赖性

- **静态方法**：静态方法不依赖于对象的实例，可以直接通过类名调用，无法访问实例变量或实例方法（除非通过对象引用）。
- **实例方法**：实例方法必须通过对象实例来调用，可以访问和操作实例变量和其他实例方法。

4. 方法重写

- **静态方法**：静态方法可以被子类中的同名静态方法隐藏（但不是方法重写），而且不能被重写。
- **实例方法**：实例方法可以被子类重写（覆盖），并且在运行时根据对象的实际类型动态分派调用。



## 静态内部类（线程安全，又能懒加载

**避免了线程不安全，延迟加载，效率高。**

在类内部有一个静态内部类，由于**静态内部类**的静态属性，仅在第一次加载类时初始化。

确保线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化。

缺点是无法传参，在类进行初始化时，其它线程无法进入。

```
public class SingletonStatic {
    private SingletonStatic() {
    }

    public static SingletonStatic getInstance() {
        return SingLineHolder.instance;
    }

    private static class SingLineHolder {
        private static final SingletonStatic instance = new SingletonStatic();
    }

}
```

**静态内部类与饿汉模式的相同之处**：

都采用了类装载的机制，来保证初始化实例时只有一个线程。

**静态内部类与饿汉模式的不同之处：**

- **饿汉式**：只要 Singleton 类被装载就会实例化，没有 Lazy-Loading 的作用。

  

- **静态内部类**：在 Singleton 类被装载时，并不会立即实例化。而是在需要实例化时，调用 getInstance 方法，才会装载SingletonInstance 类，从而完成 Singleton 的实例化。



## 枚举（线程安全，能懒加载，不能被反射破坏

不嫩被反射破坏

多线程安全，写法非常简洁，自动支持序列化机制，绝对防止多次实例化。

缺点是不能通过 reflection attack 来调用私有构造方法。

```
public enum  SingletonEnum {
    INSTANCE;
    SingletonEnum() {}
    public void getName() {}
}
```

## 单例模式的应用场景

**单例模式**通常用于想要控制实例数目、节省系统资源的场景中。

一些常见的应用场景：

-  工具类对象；

-  频繁访问数据库或文件的对象；

  需要频繁的进行创建和销毁的对象；

- 创建对象时耗时过多、或耗费资源过多，但又频繁要用到的对象。

  

  ## 单例模式的优缺点

  **单例模式的优点：**

  - 避免对资源的多重占用；
  - 简化对象管理，提供全局访问点，方便在整个应用程序中共享实例；
  - 提供了对唯一实例的受控访问。

  **单例模式的缺点：**

  - 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难；
  - 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态;
  - 单例类职责过重，在一定程度上违背了单一职责。

  

  ## 单例模式选型参考

  单例模式的选型参考：

  - 枚举方式通常被认为是最佳实践，因为它既简洁、又线程安全；
  - 一般情况下使用饿汉式，不使用懒汉式、懒汉式（同步方法）；
  - 只有在要明确实现 lazy loading 效果时，才会使用静态内部类方式；
  - 如果有其他特殊的需求，可以考虑使用双重检查锁。

  

  

  # Java是值传递还是引用传递

  值传递

  JVM虚拟机中划分了好几块内存区域，其中就有一个堆空间和一个栈空间。我们创建的所有对象都存放在堆中，基本数据类型和局部变量在栈中

  对于基本数据类型，直接在栈中创建了一个副本

  对于引用数据类型，我们拷贝的是栈中对象的引用，即对象在堆中的地址，形参和实参指向堆中同一个对象

  当我们对形参重新赋值时，实参是不会改变的

  形参始终都是一个副本，无法通过形参改变实参

  ![image-20240412131234899](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240412131234899.png)

  ![image-20240412131246672](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240412131246672.png)

  ![image-20240412131256741](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240412131256741.png)
  
  ![image-20240412131323555](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240412131323555.png)



# 介绍一下熟悉的设计模式

**单例模式**



**代理模式**

代理模式是一种比较好理解的设计模式。简单来说就是 **我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。**

**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。**



**享元模式**

享元模式是一种结构型的设计模式。它的主要目的是通过共享对象来减少系统种对象的数量，其本质就是缓存共享对象，降低内存消耗。

享元模式将需要重复使用的对象分为两个部分：内部状态和外部状态。

内部状态是不会变化的，可以被多个对象共享，而外部状态会随着对象的使用而改变。比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。

![image-20240606144053486](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240606144053486.png)



# JAVA是值传递



java是值传递；值传递是指在调用方法时将实际参数拷贝一份传递到方法中，这样在方法中如果对参数进行修改，将不会影响到实际参数；当传的是基本类型时，传的是值的拷贝，对拷贝变量的修改不影响原变量；当传的是引用类型时，传的是引用地址的拷贝，但是拷贝的地址和真实地址指向的都是同一个真实数据，因此可以修改原变量中的值。
当传的是基本类型时，传的是值的拷贝，对拷贝变量的修改不影响原变量；当传的是引用类型时，传的是引用地址的拷贝，但是拷贝的地址和真实地址指向的都是同一个真实数据，因此可以修改原变量中的值；当传的是String类型时，虽然拷贝的也是引用地址，指向的是同一个数据，但是String的值不能被修改，因此无法修改原变量中的值。

首先来解释一下什么是引用传递，什么是值传递。

引用传递（pass by reference）是指在调用方法时将实际参数的地址直接传递到方法中，那么在方法中对参数所进行的修改，将影响到实际参数。

值传递（pass by value）是指在调用方法时将实际参数拷贝一份传递到方法中，这样在方法中如果对参数进行修改，将不会影响到实际参数。

String变量比较特殊，我们看String的源码可以知道，String的值是通过内部的char[]数组来维护的，但是这个数据定义的是[final类](https://so.csdn.net/so/search?q=final类&spm=1001.2101.3001.7020)型的，因此，String的值是不可变的。我们平时修改String的值，其实是重新new了一个String对象

# JAVA反射机制的用途

[Java反射](https://so.csdn.net/so/search?q=Java反射&spm=1001.2101.3001.7020)是一种强大的特性，它允许我们在运行时获取和操作类的信息。通过反射，我们可以动态地创建对象、调用方法、访问和修改字段，甚至可以实现动态代理。



# 



# final、finally、finalize的区别

**final：**修饰符（关键字）有三种用法：修饰类、变量和方法。修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，也同样只能使用，不能在子类中被重写。

**finally：**通常放在 try…catch 的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中。

**finalize：**Object 类中定义的方法，Java 中允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize() 方法可以整理系统资源或者执行其他清理工作。

finalize是java.lang.Object中的⽅法，也就是每⼀个对象都有这个⽅法，⼀个对象的finalize⽅法只会调⽤⼀

次，调⽤了不⼀定被回收，因为只有对象被回收的时候才会被回收，就会导致前⾯调⽤，后⾯回收的时候出现问题，不推荐使⽤。



# 深拷贝和浅拷贝

> 拷贝分为引用拷贝和对象拷贝；深拷贝和浅拷贝都是属于对象拷贝
>
> **浅拷贝可以创建一个对象的副本，把基本数据类型和final修饰的数据类型 复制一份，但是如果是引用数据类型，只能复制地址。**
>
> **浅拷贝是无法把引用对象的值也拷贝的，只是拷贝了地址。**
>
> **所以如果你要把地址对应的 值也拷贝一份，可以使用深拷贝，实现的原理就是 在`clone()`方法 再拷贝一份你需要的对象**



> 1、浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
>
> 2、深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
>
> 3、浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用；深拷贝是拷贝多层，每一级别的数据都会拷贝出来。

数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和对象数据类型。

基本数据类型的特点：直接存储在栈(stack)中的数据
引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里

引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

**浅拷贝**
创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，原始对象及其副本引用同一个对象。

实现步骤：

1.实现Cloneable接口，标识这个类对象是可以被拷贝的。

2.重写Object继承而来的clone()方法。在clone方法里捕获异常。

***注意：浅拷贝里，若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原来的对象保持不变。***

**深拷贝**

```
深拷贝是一种完全拷贝，无论是基本类型还是引用类型都会完完全全的拷贝一份，在内存中生成一个新的对象。简单点说就是拷贝对象和被拷贝对象没有任何关系，互不影响
```

**通过重写方法来实现深拷贝**

与通过重写clone方法实现浅拷贝的基本思路一样，让每个引用类型属性内部都重写clone() 方法，最后在最顶层的类的重写的c1one方法中调用所有的clone方法即可实现深拷贝。

**通过对象序列化实现深拷贝**
序列化是将对象写到流中便于传输，而反序列化则是把对象从流中读取出来。无论嵌套多少个引用类型，序列化都能实现深拷贝。

***注意每个需要序列化的类都要实现 Serializable 接口，如果有某个属性不需要序列化，可以将其声明为 transient，即将其排除在克隆属性之外。***

**总结**
引用拷贝：当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容。
浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。
深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。



# String s1 = new String("abc")到底创建了几个对象？底层原理是什么？

 String s = new String("abc");方式创建对象，在内存中创建了几个对象？
 解析：两个:一个是堆空间中new结构
 		  一个是char[]对应的常量池中的数据："abc"
 String s = "abc";方式创建对象，在内存中创建了几个对象？
 解析：一个是char[]对应的常量池中的数据："abc"

**java.lang.String类的使用说明**

> 	1.String声明为final的，不可被继承
> 	2.String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小
> 	3.String内部定义了final char[] value用于存储字符串数据
> 	4.通过字面量的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)。
> 	5.字符串常量池中是不会存储相同内容(使用String类的equals()比较（重写过），返回true)的字符串的。

# String为什么是不可变的

1. 保存字符串的数组被 final 修饰且为私有的，并且 String 类没有提供/暴露修改这个字符串的⽅法。

2. String 类被 final 修饰导致其不能被继承，进⽽避免了⼦类破坏 String 不可变

# String字符串中 intern()方法的理解

> [参考文章](https://blog.csdn.net/tianyuzui6/article/details/124417267?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171383635716800215067279%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171383635716800215067279&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-6-124417267-null-null.142^v100^pc_search_result_base3&utm_term=String.intern%28%29&spm=1018.2226.3001.4187)

String.intern()方法是一种手动将字符串加入常量池中的native方法，原理如下：如果在当前类的常量池中存在与调用intern()方法的字符串等值的字符串，就直接返回常量池中相应字符串的引用，否则在常量池中复制一份该字符串（Jdk7中会直接在常量池中保存当前字符串的引用），并将其引用返回；因此，只要是堆中等值的String对象，使用intern()方法返回的都是常量池中同一个String引用，所以，这些等值的String对象通过intern()后使用==是可以匹配的。
![image-20240423094754042](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423094754042.png)

![image-20240423094825376](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423094825376.png)





# 泛型

[参考文章]( https://blog.csdn.net/weixin_45395059/article/details/126006369?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171298258116800225596597%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171298258116800225596597&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126006369-null-null.142^v100^pc_search_result_base3&utm_term=Java%E4%B8%AD%E6%B3%9B%E5%9E%8B&spm=1018.2226.3001.4187)

[参考视频]([Java中的泛型 Generics in Java_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1H94y1a7bJ/?spm_id_from=333.337.search-card.all.click&vd_source=2a200921c8b5d7294bdcf3ca4652bc6b))

## 对泛型的理解

在Java中，集合存在⼀个缺点，即当将对象添加到集合中后，集合会失去对该对象的具体数据类型的记忆，导致在取出对象时，集合将其视为 Object 类型。这是因为集合的设计者在创建时⽆法确定集合将被⽤来存储哪种类型的对象，因此选择设计成能够存储任何类型的对象，以保持通⽤性。

然⽽，这种设计带来了两个问题：

集合对元素类型没有限制，可能导致⼀些问题。例如，如果想创建⼀个只能保存 Dog 对象的集合，但程序却可以轻松地将 Cat 对象添加进去，可能引发异常。

由于集合在存储对象时丢失了对象的具体类型信息，取出对象后通常需要进⾏强制类型转换。这不仅增加了编

程的复杂性，还可能引发 ClassCastException 异常。

为了解决这些问题，Java 5引⼊了泛型（Generic）的概念，允许在创建集合时指定集合元素的具体类型，例如

List<String> 表示该列表只能保存字符串类型的对象。使⽤泛型后，程序员不能轻易地将不同类型的对象添加到集合中，⽽且在取出元素时⽆需进⾏强制类型转换，使得代码更加安全和简洁。

## 泛型擦除

泛型的本质是将数据类型参数化，它通过擦除的方式来实现，即编译器会在编译期间擦除代码中的所有泛型语法并相应的做出一些类型转换动作。

换而言之，泛型信息只存在于代码编译阶段，在代码编译结束后，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。也就是说，成功编译过后的 class 文件中不包含任何泛型信息，泛型信息不会进入到运行时阶段。

在这个例子中，我们定义了两个 ArrayList 集合，不过一个是 ArrayList< String>，只能存储字符串。一个是 ArrayList< Integer>，只能存储整型对象。我们通过 arrayString 对象和 arrayInteger 对象的 getClass() 方法获取它们的类信息并比较，发现结果为true。

明明我们在 <> 中传入了两种不同的数据类型，按照上文所说的，它们的类型参数 T 不是应该被替换成我们传入的数据类型了吗，那为什么它们的类信息还是相同呢？ 这是因为，在编译期间，所有的泛型信息都会被擦除， ArrayList< Integer > 和 ArrayList< String >类型，在编译后都会变成ArrayList< Objec t>类型。

> **那么是不是所有的类型参数被擦除后都以 Object 类进行替换呢？**
>
> - **答案是否定的，大部分情况下，类型参数 T 被擦除后都会以 Object 类进行替换；而有一种情况则不是，那就是使用到了 extends 和 super 语法的`有界类型参数`（即`泛型通配符`，后面我们会详细解释）。**
>
> - 以发现，使用到了 extends 语法的类型参数 T 被擦除后会替换为 Number 而不再是 Object。
>
>   extends 和 super 是一个限定类型参数边界的语法，extends 限定 T 只能是 Number 或者是 Number 的子类。 也就是说，在创建 Caculate 类对象的时候，尖括号 <> 中只能传入 Number 类或者 Number 的子类的数据类型，所以在创建 Caculate 类对象时无论传入什么数据类型，Number 都是其父类，于是可以使用 Number 类作为 T 的原始数据类型，进行类型擦除并替换。（这一部分涉及到了泛型通配符，在下面还会具体介绍）
>   
>

## 泛型通配符





# HashMap和Hashtable的区别

1. 线程是否安全  因为 `Hashtable` 内部的方法基本都经过`synchronized` 修饰。（如果你要保证线程安全的话就使用 `ConcurrentHashMap` 吧！）；

2. 效率问题  因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰，不要在代码中使用它；

3. 对null key和Null value的支持

   `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`。

4. 初始容量大小和每次扩充容量大小的不同：创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍

5. 底层数据结构：

   JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。`Hashtable` 没有这样的机制。

# ConcurrentHashMap 和 Hashtable 的区别

![image-20240416130307865](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240416130307865.png)

![image-20240423110355705](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423110355705.png)

# 聊一下ConcurrentHashMap

![image-20240424122337121](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240424122337121.png)



# LRU算法（Leecode146 手写LRU

LRU算法又叫淘汰算法，根据数据历史访问记录进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。

LRU: Least Recently Used, 最近最少使用，主要应用场景是缓存，缓存规则如下。
①.最近被使用或访问的数据放置在最前面;
②.每当缓存命中(即缓存数据被访问)则将数据移到头部;
③.当缓存数量达到最大值时，将最近最少访问的数据剔除;   

# Redis 常用的数据类型有哪些？

- **5 种基础数据类型**：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。
- **3 种特殊数据类型**：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。

除了上面提到的之外，还有一些其他的比如 [Bloom filter（布隆过滤器）open in new window](https://javaguide.cn/cs-basics/data-structure/bloom-filter.html)、Bitfield（位域）。

# Redis的数据类型

![image-20240515173850330](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515173850330.png)

# redis的set的常用方法

       sadd:添加多个,返回新添加的个数（已存在的不算）
       srem:从集合移除多个元素 ,返回被移除元素的数量
       sismember:检查元素item是否在集合中
       scard:返回集合总数
       smembers:返回所有元素
       srandmember:随机返回cout个元素 cout为正整数 随机元素不重复 相反可能会出现重复
       spop:随机的移除一个元素 并返回已删除的元素
       smove:如果key1中包含item 移除key1中的item 添加到key2中，成功返回1 失败返回0
       差运算 sdiffstore:将存在于key集合但是不存在key1…集合的其他元素 放到newkey里面（咬掉一口剩下的）
       交运算 sinter:返回所有集合的交集（返回我们都有的的）
       交运算 sinterstore:返回多个集合的交集生成集合newkey
       并运算 sunion:返回不重复的所有元素
       并运算 sunion:放到newkey中
# 常见排序算法

 [【大厂高频面试笔试手撕代码】15分钟教会你五种排序算法（冒泡，插入，选择，快排，归并）——来不及解释了，快上车！！！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV13K4y1F7rM/?spm_id_from=333.337.search-card.all.click&vd_source=2a200921c8b5d7294bdcf3ca4652bc6b)

**冒泡排序（时间复杂度为O(n^2)**（是一种稳定算法
 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。假设长度为n的数组arr，要按照从小到大排序。则冒泡排序的具体过程可以描述为：首先从数组的第一个元素开始到数组最后一个元素为止，对数组中相邻的两个元素进行比较，如果位于数组左端的元素大于数组右端的元素，则交换这两个元素在数组中的位置。这样操作后数组最右端的元素即为该数组中所有元素的最大值。接着对该数组除最右端的n-1个元素进行同样的操作，再接着对剩下的n-2个元素做同样的操作，直到整个数组有序排列。

**插入排序（时间复杂度为O(n^2)**（是一种稳定算法
 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。例如要将数组arr=[4,2,8,0,5,1]排序，可以将4看做是一个有序序列，将[2,8,0,5,1]看做一个无序序列。无序序列中2比4小，于是将2插入到4的左边，此时有序序列变成了[2,4]，无序序列变成了[8,0,5,1]。无序序列中8比4大，于是将8插入到4的右边，有序序列变成了[2,4,8],无序序列变成了[0,5,1]。以此类推，最终数组按照从小到大排序。

**选择排序（时间复杂度为O(n^2)**（不是一种稳定算法
 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。具体来说，**假设长度为n的数组arr，要按照从小到大排序，那么先从n个数字中找到最小值min1，如果最小值min1的位置不在数组的最左端(也就是min1不等于arr[0])，则将最小值min1和arr[0]交换，接着在剩下的n-1个数字中找到最小值min2，如果最小值min2不等于arr[1]，则交换这两个数字，依次类推，直到数组arr有序排列。**

**快速排序（时间复杂度为O(n log n)**（不是一种稳定算法（分治思想（自顶向下
 快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。快速排序的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，已达到整个序列有序。一趟快速排序的具体过程可描述为：**从待排序列中任意选取一个记录(通常选取第一个记录)作为基准值，然后将记录中关键字比它小的记录都安置在它的位置之前，将记录中关键字比它大的记录都安置在它的位置之后。这样，以该基准值为分界线，将待排序列分成的两个子序列。它是处理大数据最快的排序算法之一了。**

**归并排序（时间复杂度为O(n log n)**（是一种稳定算法（分治思想（自底向上
 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。代价是需要额外的内存空间。若将两个有序表合并成一个有序表，称为2-路归并。

# 死锁产生的四个必要条件 如何预防和避免

![image-20240416134256803](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240416134256803.png)

# 进程和线程的区别

一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)\**资源，但是每个线程有自己的\**程序计数器**、**虚拟机栈** 和 **本地方法栈**。

**总结：** **线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。**

# 协程与线程

1. 协程是轻量级线程,全部都在用户态,因此系统消耗资源非常低,非常高效.不像线程一样是内核线程,由cpu调度,造成上下文切换,浪费资源.
2. 线程实现数据共享的方式是共享内存,而协程是通信,这就避免了线程安全的问题,避免了锁竞争.

3. 系统是察觉不到协程的存在的，所以只有一个处理器内核会被分配给该进程 ，也就不能发挥多核 CPU 的优势,所以协程适用于I/O 阻塞型场景.不适用于cpu密集型.
   

# Java中如何实现线程间的通信？

> 1、等待/通知机制： 使用Object类的wait(), notify()和notifyAll()方法来实现线程之间的等待和通知。
>
> 2、使用管道通信： 通过PipedInputStream和PipedOutputStream或者PipedReader和PipedWriter实现线程间的数据传输。
>
> 3、使用阻塞队列： 如ArrayBlockingQueue、LinkedBlockingQueue等，线程可以安全地从队列中添加或移除元素。
>
> 4、使用信号量： Semaphore可以控制对共享资源的访问。
>
> 5、利用并发工具类： 如CyclicBarrier, CountDownLatch, Exchanger等，这些工具类提供了更高层次的线程间协调功能。

# 创建线程的方式

![image-20240416135632630](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240416135632630.png)

![image-20240423115757672](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423115757672.png)

# 线程池的核心参数

![image-20240423120536405](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423120536405.png)

![image-20240423120642058](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423120642058.png)

# 线程池的创建方式  为什么不推荐使用Executors

**方式一：通过`ThreadPoolExecutor`构造函数来创建（推荐）。**

**方式二：通过 `Executor` 框架的工具类 `Executors` 来创建。**

**通过`Executors`工具类可以创建多种类型的线程池，包括：**

- `FixedThreadPool`：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
- `SingleThreadExecutor`： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
- `CachedThreadPool`： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。
- `ScheduledThreadPool`：给定的延迟后运行任务或者定期执行任务的线程池。

**`Executors` 返回线程池对象的弊端如下：**

- `FixedThreadPool` 和 `SingleThreadExecutor`:使用的是无界的 `LinkedBlockingQueue`，任务队列最大长度为 `Integer.MAX_VALUE`,可能堆积大量的请求，从而导致 OOM。
- `CachedThreadPool`:使用的是同步队列 `SynchronousQueue`, 允许创建的线程数量为 `Integer.MAX_VALUE` ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。
- `ScheduledThreadPool` 和 `SingleThreadScheduledExecutor`:使用的无界的延迟阻塞队列`DelayedWorkQueue`，任务队列最大长度为 `Integer.MAX_VALUE`,可能堆积大量的请求，从而导致 OOM。



## 拒绝策略

> 1.AbortPolicy：直接抛出异常，默认策略；
>
> 2.CallerRunsPolicy：用调用者所在的线程即主线程来执行任务；
>
> 3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并将当前任务放入阻塞队列；
>
> 4.DiscardPolicy：直接丢弃任务；

# 守护线程

**Java中守护线程和本地线程区别**
java中的线程分为两种：守护线程（Daemon）和用户线程（User）。
任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。

**两者的区别：** 
唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。

# mysql有哪些索引

按照底层存储方式角度划分：

- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

按照应用维度划分：

- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- 普通索引：仅加速查询。
- 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。



# B树和B+树的区别

![image-20240518163552450](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240518163552450.png)



# mysql索引为什么使用B+树而不是B树

B树与B+树对比:

①：磁盘读写代价B+树更低；

这个很好理解，由于B-树节点内部每个 key 都带着 data 域，而B+树节点只存储 key 的副本，真实的 key 和 data 域都在叶子节点存储。前面说过磁盘是分 block 的，一次磁盘 IO 会读取若干个 block，具体和操作系统有关，那么由于磁盘 IO 数据大小是固定的，在一次 IO 中，单个元素越小，量就越大。这就意味着**B+树单次磁盘 IO 的信息量大于B-树**，从这点来看B+树相对B-树磁盘 IO 次数少。

②：查询效率B+树更加稳定；

③：B+树便于扫库和区间查询

# 索引失效的场景

违反最左前缀法则

范围查询右边的列，不能使用索引

不要在索引列上进行运算操作， 索引将失效

字符串不加单引号，造成索引失效。

(类型转换)以%开头的Like模糊查询，索引失效

# 慢sql是如何优化的

> 分析My[SQL语句](https://so.csdn.net/so/search?q=SQL语句&spm=1001.2101.3001.7020)查询性能的方法除了使用 EXPLAIN 输出执行计划，还可以让MySQL记录下查询超过指定时间的语句，我们将超过指定时间的SQL语句查询称为“慢查询”。
>
> 慢查询日志就是记录这些sql的日志。

1.表的设计优化，数据类型的选择

2.索引优化，索引创建原则

3.sql语句优化，避免索引失效，避免使用select *  ….

4.主从复制、读写分离，不让数据的写入，影响读操作

5.分库分表 

![image-20240416153510930](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240416153510930.png)

# 七层网络模型了解吗

**OSI 七层模型** 是国际标准化组织提出的一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：

**TCP/IP 四层模型** 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：

1. 应用层

2. 传输层

3. 网络层

4. 网络接口层

   ![image-20240417133138487](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240417133138487.png)

# 各层常见协议举例

1.应用层

**HTTP（Hypertext Transfer Protocol，超文本传输协议）**：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。

**SSH（Secure Shell Protocol，安全的网络传输协议）**：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务

**DNS（Domain Name System，域名管理系统）**: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。

2.传输层

**TCP（Transmission Control Protocol，传输控制协议 ）**：提供 **面向连接** 的，**可靠** 的数据传输服务。

**UDP（User Datagram Protocol，用户数据协议）**：提供 **无连接** 的，**尽最大努力** 的数据传输服务（不保证数据传输的可靠性），简单高效。

3.网络层

**IP（Internet Protocol，网际协议）**：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。

**ARP（Address Resolution Protocol，地址解析协议）**：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。

# 从输入URL到页面展示到底发生了什么（请求在网络上经过的步骤

![image-20240501155655389](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240501155655389.png)



# HTTP 和 HTTPS 有什么区别？

![image-20240426101446609](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240426101446609.png)



# TCP和UDP的区别

**是否面向连接**：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。

**是否是可靠传输**：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。

**是否有状态**：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（**这很渣男！**）。

**传输效率**：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。

**传输形式**：TCP 是面向字节流的，UDP 是面向报文的。

**首部开销**：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。

**是否提供广播或多播服务**：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；



# 三次握手和四次挥手（需复习

为什么是三次和四次？

# TCP如何保证传输可靠性（需复习

![image-20240423125104621](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423125104621.png)

# nginx七层和四层

**四层**就是基于IP + 端口的负载均衡，通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；

**七层**通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器七层就是基于 URL 等应用层信息的负载均衡。

4层是指传输层的 tcp / udp 。

7层是指应用层，通常是http 。

**代理原理**

4层 用的是NAT技术。NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”，请求进来的时候，nginx修改数据包里面的目标和源IP和端口，然后把数据包发向目标服务器，服务器处理完成后，nginx再做一次修改，返回给请求的客户端。

7层 代理：需要读取并解析http请求内容，然后根据具体内容(url,参数，cookie,请求头)然后转发到相应的服务器，转发的过程是：建立和目标机器的连接，然后转发请求，收到响应数据在转发给请求客户端

**优缺点对比**

1.性能：
理论上4层要比7层快，因为7层代理需要解析数据包的具体内容，需要消耗额外的cpu。但nginx具体强大的网络并发处理能力， 对于一些慢连接，nginx可以先将网络请求数据缓冲完了一次性转发给上游server,这样对于上游网络并发处理能力弱的服务器(比如tomcat)，这样对tomcat来说就是慢连接变成快连接(nginx到tomcat基本上都是可靠内网),从而节省网络数据缓冲时间，提供并发性能。

2.灵活性：
由于4层代理用的是NAT，所以nginx不知道请求的具体内容，所以nginx啥也干不了。 用7层代理，可以根据请求内容(url,参数，cookie,请求头)做很多事情，


# mysql插入时会有锁吗？是什么级别的锁？

在 MySQL 中，插入操作会涉及到行级锁和表级锁，具体涉及到哪种锁取决于存储引擎和事务的隔离级别。

如果使用的是 MyISAM 存储引擎，插入操作会锁定整个表，这是表级锁。这也意味着在插入操作期间，其他用户无法对该表进行任何操作。这显然会导致性能下降，因为表级锁定会限制并发，因此不建议在需要高并发的环境中使用 MyISAM 存储引擎。

而如果使用的是 InnoDB 存储引擎，插入操作会锁定新插入的行，这属于行级锁。当插入一行数据时，会对此行加锁，直到插入完成后才释放锁，这可以避免多个用户同时插入同一行数据的问题。如果多个用户同时插入不同的行，则可以并发执行，从而提高性能。但是需要注意的是，如果使用的是读未提交的隔离级别，则会导致幻读问题。

总之，在插入操作时，应该选择正确的存储引擎，并考虑事务的隔离级别，以避免潜在的性能问题和数据一致性问题。



# 并发事务带来哪些问题？怎么解决这些问题呢？MySQL的默认隔离级别是？

![image-20240416220422820](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240416220422820.png)

# JVM垃圾回收算法

标记清除算法：垃圾回收分为2个阶段，分别是标记和清除,效率高,有磁盘碎片，内存不连续

标记整理算法：标记清除算法一样，将存活对象都向内存另一端移动，然后清理边界以外的垃圾，无碎片，对象需要移动，效率低。老年代的GC常用

复制算法：将原有的内存空间一分为二，每次只用其中的一块,正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收;无碎片，内存使用率低。一般年轻代的GC使用

![image-20240416221706272](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240416221706272.png)



# Redis中hash是如何扩容的 为什么用渐进式rehash

为了实现从键到值的快速访问，Redis 使用了一个[哈希表](https://so.csdn.net/so/search?q=哈希表&spm=1001.2101.3001.7020)来保存所有键值对。

哈希表存在[哈希冲突](https://so.csdn.net/so/search?q=哈希冲突&spm=1001.2101.3001.7020)问题和 rehash 可能带来的操作阻塞

Redis 解决哈希冲突的方式，就是链式哈希。就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接（叫做哈希冲突链）。

![image-20240423133625205](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423133625205.png)

![image-20240423133710530](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423133710530.png)

![image-20240423133739037](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423133739037.png)



# hashmap的底层实现原理

![image-20240417131552692](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240417131552692.png)



# hashmap的put方法具体流程？

![image-20240507211038918](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240507211038918.png)

![image-20240507211102868](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240507211102868.png)

# hashmap中有哪些成员变量

> 默认的初始容量
>
> static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
>
> 默认的加载因子
>
> static final float DEFAULT_LOAD_FACTOR = 0.75f;
>
> ##### **table用来初始化(必须是二的n次幂)(重点)**
>
> transient HashMap.Node<K,V>[] table; // 存储元素的数组
>
> ##### **HashMap中存放元素的个数(重点)**
>
> transient int size; // *存放元素的个数，注意这个不等于数组的长度。*
>
> ##### 当链表的值超过8则会转红黑树(**1.8新增**)
>
> static final int TREEIFY_THRESHOLD = 8;
>
> ##### **当链表的值小于6则会从红黑树转回链表**
>
>  static final int UNTREEIFY_THRESHOLD = 6;

# 进程调度算法

![image-20240417133943557](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240417133943557.png)

**时间片轮转调度算法的优缺点：**

优点：公平，响应快，适用于分时操作系统。

缺点：由于高频率的进程切换，因此有一定的开销，不区分任务的紧急程度。

# Redis什么情况下会阻塞

[参考文章](https://blog.csdn.net/issunmingzhi/article/details/110086937?ops_request_misc=&request_id=&biz_id=102&utm_term=redis%E9%98%BB%E5%A1%9E&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-110086937.142^v100^pc_search_result_base3&spm=1018.2226.3001.4187)

- 慢查询
- bigkey大对象
- swap
- fork子进程
- AOF刷盘阻塞
- Redis输入、输出缓冲区导致的阻塞
- 网络问题

**bigkey大对象**
bigkey大对象可能导致的问题如下

内存空间不均衡：例如在Redis Cluster中，其会造成节点的内存空间使用不均匀
超时阻塞：由于Redis单线程的特性，操作bigkey比较耗时，意味着阻塞Redis的可能性增大
网络阻塞：每次获取bigkey产生的网络流量较大。

**fork子进程**

在 RDB 生成和 AOF 重写时，会 fork 一个子进程完成持久化工作，当 fork 操作执行太过耗时也会造成阻塞，阻塞原因是该操作会复制父进程的空间内存表，即 fork 操作耗时跟内存量（数据集）关系较大。

**AOF刷盘阻塞**

开启 AOF，文件刷盘一般每秒一次，硬盘压力过大时，fsync 需要等待写入完成。

# Redis是单线程的，但是为什么还那么快，可以从底层原理说一说吗

1. Redis是纯内存操作，执行速度非常快

2. 采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题

3. 使用I/O多路复用模型，非阻塞IO

4. redis内部的数据结构（redis内置了多种优化过后的数据类型/结构实现，性能非常高。

![image-20240417152253122](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240417152253122.png)

**比如说Redis中的String**,虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 **简单动态字符串**（Simple Dynamic String，**SDS**）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。

![image-20240417152442910](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240417152442910.png)

# zset底层实现

zset有两种不同的实现，分别是zipList和skipList。

**zipList：**
满足以下两个条件：

[score,value]键值对数量少于128个；
每个元素的长度小于64字节；
**skipList:**
不满足以上两个条件时使用跳表（组合了hash和skipList）

hash用来存储value到score的映射，这样就可以在O(1)时间内找到value对应的分数；
skipList按照从小到大的顺序存储分数；
skipList每个元素的值都是[score,value]对

## 跳表

### 什么是跳表？

[参考文章](https://blog.csdn.net/weichi7549/article/details/107335133?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171385172916800226518318%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171385172916800226518318&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-107335133-null-null.142^v100^pc_search_result_base3&utm_term=zset%E5%BA%95%E5%B1%82&spm=1018.2226.3001.4187)

对链表进行改造，在链表上建索引，即每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引。**这种链表加多级索引的结构，就是跳表。**

**跳表的特点:**

由许多层结构组成。
每一层都是一个有序的链表。
最底层 (Level 1) 的链表包含所有元素。
如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。
每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。
**跳表的优点：**
跳表可以保证增、删、查等操作时的时间复杂度为O(logN)，且维持结构平衡的成本比较低，完全依靠随机。而二叉查找树在多次插入删除后，需要Rebalance来重新调整结构平衡。(旨在插入操作中，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。)

**跳表的缺点：**
跳表占用的空间比较大（多级索引），其实就是一种空间换时间的思想。

![image-20240423140314777](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423140314777.png)

# Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？

![image-20240515132415664](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515132415664.png)



# redis数据类型有哪些？分别适用于什么场景（看javaguide 记不住 得不断复习



# 过滤器和拦截器的区别

![image-20240420145624714](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240420145624714.png)

过滤器 和 拦截器 均体现了`AOP`的编程思想，都可以实现诸如日志记录、登录鉴权等功能，但二者的不同点也是比较多的，接下来一一说明。

**1.底层实现原理不同**

过滤器和拦截器 底层实现方式大不相同，`过滤器` 是基于函数回调的，`拦截器` 则是基于Java的反射机制（动态代理）实现的。

**2.使用范围不同**

我们看到过滤器 实现的是 `javax.servlet.Filter` 接口，而这个接口是在`Servlet`规范中定义的，也就是说过滤器`Filter` 的使用要依赖于`Tomcat`等容器，导致它只能在`web`程序中使用。

而拦截器(`Interceptor`) 它是一个`Spring`组件，并由`Spring`容器管理，并不依赖`Tomcat`等容器，是可以单独使用的。不仅能应用在`web`程序中，也可以用于`Application`、`Swing`等程序中。

**3.触发时机不同**

`过滤器` 和 `拦截器`的触发时机也不同

过滤器`Filter`是在请求进入容器后，但在进入`servlet`之前进行预处理，请求结束是在`servlet`处理完以后。

拦截器 `Interceptor` 是在请求进入`servlet`后，在进入`Controller`之前进行预处理的，`Controller` 中渲染了对应的视图之后请求结束。

**4.拦截的请求范围不同**

过滤器几乎可以对所有进入容器的请求起作用，而拦截器只会对`Controller`中请求或访问`static`目录下的资源请求起作用。

# **Integer a1=100 Integer a2=100，a1==a2？的运行结果？**

a1==a2 的执行结果是 true

原因是 Integer 内部用到了享元模式的设计，针对-128 到 127 之间的数字做了缓存。

使用 Integer a1=100 这个方式赋值时，Java 默认会通过 valueOf 对 100 这个数字进行装箱操作，

从而触发了缓存机制，使得 a1 和 a2 指向了同一个 Integer 地址空间。



# 布隆过滤器（解决缓存穿透）为什么不能删除

布隆过滤器对元素的删除，肯定不可以，会出现问题，比如上面添加元素的 bit 位 5 被两个变量的哈希值共同覆盖的情况下，一旦我们删除其中一个值。例如“xinlang”而将其置位 0，那么下次判断另一个值例如“baidu”是否存在的话，会直接返回 false，而实际上我们并没有删除它，这就导致了误判的问题。

# @Autowired和@Resource的区别

1. @Autowired 是根据 type 来匹配，@Resource 可以根据 name 和 type 来匹配，默认是 name

匹配。

2. @Autowired 是 Spring 定义的注解，@Resource 是 JSR 250 规范里面定义的注解，而 Spring

对 JSR 250 规范提供了支持。

3. @Autowired 如果需要支持 name 匹配，就需要配合@Primary 或者@Qualifier 来实现

# redis的内存淘汰策略

![image-20240420160239110](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240420160239110.png)



# JVM中对象的创建

![JVM对象实例化脑图](https://img-blog.csdnimg.cn/8cd37189c1fd44a18ad979e691cdc94b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55uu55uu5rKQ5rKQ,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

> [参考文章](https://blog.csdn.net/qq_43911324/article/details/122769728?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171360038416777224448663%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171360038416777224448663&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-122769728-null-null.142^v100^pc_search_result_base3&utm_term=JVM%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1&spm=1018.2226.3001.4187)

![image-20240421135920188](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240421135920188.png)

# JVM类的生命周期

![image-20240420165104758](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240420165104758.png)

# JVM中有哪些场景会触发类的加载？ 

**类加载器是什么?**

Java程序启动时(或者在运行的过程中), jvm(Java虚拟机)会完成类的加载, 其中第一步就是使用类加载器classLoader将二进制流(.class文件)加载到内存中.

类加载器就是这样一个用来加载类文件的关键工具.

**什么时候会触发类的加载?**

Java虚拟机并没有强制要求何时必须完成对类的加载, 但是要求了类如果需要初始化的时候, 必须在这之前完成类的加载.

因此可以认为类初始化是类加载的触发时间点

**Java虚拟机规定，有且只有以下五种情况时，必须立即对类进行初始化：**

1. 虚拟机在用户指定包含main方法的主类后启动时

2. 当使用 new 关键字对类进行实例化时、读取或者写入类的静态字段时、调用类的静态方法时，必须先触发对该类的实例化

3. 使用反射对类进行反射调用时，如果该类没有初始化，必须先触发其初始化

4. 初始化一个类，而该类父类还未初始化时，需要先对其父类进行初始化

5. 在JDK7之后的版本中使用动态语言支持，java.lang.invoke.MethodHandle实例解析的结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，而该句柄对应的类还未初始化时，必须先触发其实例化

**什么样的类是同一个类?**

jvm判断两个类是否是同一个类有两个条件

1.类的全名相同 (即包全路径 + 类名)

2.类加载器相同

**类加载器有哪些?**

如果只是常规使用, 我们无需关心类加载器的相关问题, jvm中内置了3个类加载器已经能满足我们的日常需要.

内置类加载器根据层级从上往下依次是启动类加载器 -> 扩展类加载器 -> 应用程序类加载器

# 双亲委派机制

![image-20240420165229025](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240420165229025.png)

# 一个线程包含哪些状态

![image-20240420165841834](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240420165841834.png)

# 线程池的执行原理

![image-20240420170207113](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240420170207113.png)

# 线程同步有哪些策略和类？有没有实测过关键字的性能







## JAVA内存泄露的排查思路

1、通过jmap或设置jvm参数获取堆内存快照dump

2、通过工具， VisualVM去分析dump文件，VisualVM可以加载离线的dump文件

3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题

4、找到对应的代码，通过阅读上下文的情况，进行修复即可

# CPU飙高排查方案与思路？（参考黑马八股

1.使用top命令查看占用cpu的情况, 通过top命令查看后，可以查看是进程40940中占用cpu较高

2.查看该进程中的线程信息，通过以上分析，在进程40940中的线程40950占用cpu较高

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240421160100681.png" alt="image-20240421160100681" style="zoom:50%;" />

3.可以根据线程 id 找到有问题的线程，进一步定位到问题代码的源码行号（这一步还包含了一个十进制转十六进制的问题

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240421160246825.png" alt="image-20240421160246825" style="zoom:50%;" />

4.查看这个线程中的代码   ---》 发现第9行处有一个while(true)死循环



# ArrayList和LinkedList的区别

1.底层数据结构

ArrayList 是动态数组的数据结构实现LinkedList 是双向链表的数据结构实现

2.操作数据效率

**查询**

ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)

**增删**

ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)

3.内存空间占用

ArrayList底层是数组，内存连续，节省内存LinkedList 是双向链表需要存储数据，和两个指针，更占用内存

4.是否线程安全

# 为什么LinkedList的插入会比ArrayList的插入效率高（不太理解



# HashMap存在什么问题

![image-20240422134512363](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240422134512363.png)

![image-20240422134853015](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240422134853015.png)

![image-20240422134722160](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240422134722160.png)

# hashmap在1.7情况下的多线程死循环问题

![image-20240422135456261](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240422135456261.png)

# 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的？ 

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240511150823756.png" alt="image-20240511150823756" style="zoom:50%;" />

TreeMap和LinkedHashmap都是有序的。（TreeMap默认是key升序(字典排序）），LinkedHashmap默认是数据插入顺序）

TreeMap是基于比较器Comparator来实现有序的（内部结构为红黑树）。

LinkedHashmap是基于链表来实现数据插入有序的。



HashMap是无序的集合，存储元素和取出元素的顺序有可能不一致

![img](https://img-blog.csdnimg.cn/20210724171900310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NDU4MDIw,size_16,color_FFFFFF,t_70)

# 哪些中间件用到了raft算法



# mysql和redis数据不一致问题（见项目总结

同步方式

1.延时双删

2.redisson实现的分布式锁

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513172427585.png" alt="image-20240513172427585" style="zoom:67%;" />

异步方式

1.在应用中去写消息队列

无论是先操作缓存，还是先操作数据库，但凡后者执行失败了，我们就可以发起重试，尽可能地去做「补偿」；或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。因为消息队列的特性，正好符合我们的需求：

- **消息队列保证可靠性**：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）
- **消息队列保证消息成功投递**：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）

2.订阅数据库变更日志（例如阿里的 canal），再操作缓存

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240513172201269.png" alt="image-20240513172201269" style="zoom:80%;" />

使用这种方案的优点在于：

- **无需考虑写消息队列失败情况**：只要写 MySQL 成功，Binlog 肯定会有
- **自动投递到下游队列**：canal 自动把数据库变更日志「投递」给下游的消息队列

**我们可以得出结论，想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。**



# JAVA各种类型各占多少字节,多少位

![image-20240511145539245](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240511145539245.png)

# JDK代理模式和CGLIB代理模式

如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。

## 继续问：为什么JDK代理模式只能代理 实现了接口的类或者代理接口？（没看



# JVM由哪些部分组成

![image-20240423162048467](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423162048467.png)

# 方法区中存的是什么？方法区是怎么实现的？

当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

![image-20240423162418636](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423162418636.png)

# CAS你知道吗？

![image-20240423163859394](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423163859394.png)

# AQS  ABA

![image-20240424113633948](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240424113633948.png)



# Lock和Synchronized的区别

1.**从功能角度来看**，Lock 和 Synchronized 都是 Java 中用来解决线程安全问题的工具。



2.**从特性来看，**

**a.** Synchronized 是 Java 中的同步关键字，Lock 是 J.U.C 包中提供的接口，这个接口有很多实

现类，其中就包括 ReentrantLock 重入锁

**b.** Synchronized 可以通过两种方式来控制锁的粒度，（如图）

一种是把 synchronized 关键字修饰在方法层面，另一种是修饰在代码块上

**Lock 锁的粒度**是通过它里面提供的 lock(）和 unlock(）方法决定的，包裹在这两个方法之间

的代码能够保证线程安全性。而锁的作用域取决于 Lock 实例的生命周期。

**c.** Lock 比 Synchronized 的灵活性更高，Lock 可以自主决定什么时候加锁，什么时候释放锁，

只需要调用 lock(）和 unlock(）这两个方法就行

Synchronized 由于是关键字，所以它无法实现非阻塞竞争锁的方法，另外，Synchronized 锁的释放

是被动的，就是当 Synchronized 同步代码块执行完以后或者代码出现异常时才会释放。

**d.** Lock 提供了公平锁和非公平锁的机制，公平锁是指线程竞争锁资源时，如果已经有其他线程

正在排队等待锁释放，那么当前竞争锁资源的线程无法插队。而非公平锁，就是不管是否有线

程在排队等待锁，它都会尝试去竞争一次锁。 Synchronized 只提供了一种非公平锁的实现。



**3.从性能方面来看**，Synchronized 和 Lock 在性能方面相差不大，在实现上会有一些区别，

Synchronized 引入了偏向锁、轻量级锁、重量级锁以及锁升级的方式来优化加锁的性能，而 Lock

中则用到了自旋锁的方式来实现性能优化。

# 死锁产生的条件  如何避免死锁

![image-20240424121448717](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240424121448717.png)



# 事务四大特性 及如何实现的

![image-20240423165404279](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423165404279.png)



redo log可以实现事务的持久性

undo log用来实现事务的一致性和原子性

![image-20240430183746214](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240430183746214.png)

# mysql中用到的3种日志文件知道吗

redolog     undolog    binlog

**1.redolog**

redo log包括两部分：一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo log file)。mysql每执行一条DML语句，先将记录写入redo log buffer，后续某个时间点再一次性将多个操作记录写到redo log file。这种先写日志，再写磁盘的技术就是MySQL里经常说到的WAL(Write-Ahead Logging) 技术

记录的是数据页的物理变化，服务宕机可用来同步数据,保证了事务的持久性，



2.**undo log ：**记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，保证了事务的原子性和一致性。还可以实现MVCC



3.**Bin Log**记录的是逻辑日志，即原始的SQL语句，是MySQL自带的。
作用： [数据备份](https://so.csdn.net/so/search?q=数据备份&spm=1001.2101.3001.7020)和主从同步。binlog的主要使用场景有两个，分别是主从复制和数据恢复。

![image-20240430184811286](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240430184811286.png)



# 事务的隔离性是如何保证的？（即介绍一下MVCC

![image-20240423165816086](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423165816086.png)

# 主从同步

![image-20240423165956865](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240423165956865.png)

# ThreadLocal有什么作用？底层原理知道吗？

![image-20240424132615029](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240424132615029.png)

# ThreadLocal有哪些应用场景？

**项目应用1**

用户登录 – 认证通过 – 生成jwt token返回给前端 – 前端发起请求时携带token – 拦截器请求验证token – 放行/不放行

客户端发起的每一次请求都是一个单独的线程
拦截器验证通过 将用户id通过TreadLocal放入内存，在serviceImpl阶段使用时从内存中拿出获取用户id（在程序中我们已经将TreadLocal封装成一个类 BaseContext
**项目应用2**

Pagehelper (Mybatis提供的插件）如何实现分页查询？
PageHelper是MyBatis的一个插件，内部实现了一个PageInterceptor拦截器。Mybatis会加载这个拦截器到拦截器链中。在我们使用过程中先使用PageHelper.startPage这样的语句在当前线程上下文中设置一个ThreadLocal变量，再利用PageInterceptor这个分页拦截器拦截，从ThreadLocal中拿到分页的信息，如果有分页信息拼装分页SQL（limit语句等）进行分页查询，最后再把ThreadLocal中的东西清除掉。

# 内存溢出和内存泄露

**内存溢出**

假设我们 JVM 中可用的内存空间只剩下 3M，但是我们要创建一个 5M 的对

象，那么，新创建的对象就放不进去了。这个时候，我们就叫做内存溢出。就好比是一个容量只有 300ml

的水杯，我们硬要往里面倒 500ml 的水，这时候，水就会溢出，倒不进去了，这就相当于是内存的溢

出。

**内存溢出**

在我们的业务代码执行过程中，有些对象它应该被回收，但是又有其他对象引用它，因此，

GC 不能自动回收。所以，该回收的垃圾对象没有被回收，垃圾对象越堆越多，可用内存越来越少，若

可用内存无法存放新的垃圾对象，最终导致内存泄漏。**内存泄漏最终会导致内存溢出。**

# Https是如何保证线程安全的？

# 讲一下I/O多路复用模型

# Springboot自动配置原理

![image-20240424150713324](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240424150713324.png)

# Redis持久化策略

RDB（Redis DataBase） ：简而言之，就是在指定的时间间隔内，定时的将 redis 存储的数据生成Snapshot快照并存储到磁盘等介质上；

> Redis 在持久化时会调用 glibc 的函数 fork 产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。`子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。`

> 子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存数据结构进行不间断的修改。

> 这个时候就会使用操作系统的 COW 机制来进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程相应的页面是没有变化的，还是进程产生时那一瞬间的数据。
> 

AOF（Append Of File） ：将 redis 执行过的所有写指令记录下来，在下次 redis 重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。

![image-20240425105611865](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425105611865.png)

**同时允许使用两种方式：** 其实 RDB 和 AOF 两种方式也可以同时使用，在这种情况下，如果 redis 重启的话，则会优先采用 AOF 方式来进行数据恢复，这是因为 AOF 方式的数据恢复完整度更高。

![image-20240424151004489](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240424151004489.png)

![image-20240424151015029](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240424151015029.png)

# Redis分布式锁

![image-20240425102758051](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425102758051.png)

# 多叉树相较于二叉树来讲作为索引的优势

![image-20240425123405257](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425123405257.png)

# 红黑树和AVL树

![image-20240425124031481](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425124031481.png)

# hashmap为什么用红黑树而不用其他树

**为什么不选用AVL树**

![image-20240425124601183](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425124601183.png)

**为什么不用B树和B+树**

![image-20240425124712702](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425124712702.png)

# jwt token是如何生成的

>  用户登录 – 认证通过 – 生成jwt token返回给前端 – 前端发起请求时携带token – 拦截器请求验证token – 放行/不放行

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/355982c1092b441da5c4832d895ebe65.png)

# 除了用jwt token , 有无别的方案

> [参考文章](https://blog.csdn.net/huangpb123/article/details/103933400?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171402114116800213029735%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171402114116800213029735&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-103933400-null-null.142^v100^pc_search_result_base3&utm_term=cookie%E5%92%8Csession%E5%92%8Ctoken%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187)

![image-20240425125840983](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425125840983.png)

cookie：非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求会把该cookie发送给服务器。

区别：cookie数据存放在客户的浏览器上，session数据放在服务器上。将重要信息存放在Session中，其他信息如果需要保留，可以放在cookie中。

![image-20240425131519941](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425131519941.png)

![image-20240425131952644](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425131952644.png)

# JAVA异常

> [参考文章](https://blog.csdn.net/ligonglanyuan/article/details/122714586?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171401084216777224415698%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171401084216777224415698&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122714586-null-null.142^v100^pc_search_result_base3&utm_term=java%E5%BC%82%E5%B8%B8&spm=1018.2226.3001.4187)

        Error和Exception都有一个共同的根类是Throwable类。
    
        Error是系统中的错误，程序员是不能改变的和处理的，一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。因此我们编写程序时不需要关心这类错误。
    
        Exception，也就是我们经常见到的一些异常情况，表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。
![img](https://img-blog.csdnimg.cn/721cce36b3f741a388d0a3b61fc6da07.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5piv5rOi5ZOp5Liq5rOi,size_16,color_FFFFFF,t_70,g_se,x_16)

        Java的异常(包括Exception和Error)从广义上分为检查异常（checked exceptions）和非检查的异常（unchecked exceptions）。
    
        其中根据Exception异常进行划分，可分为运行时异常和非运行时异常。
    
        需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了。
**非检查异常**

RuntimeException与其子类，以及错误（Error）。

**检查异常**

除了RuntimeException与其子类，以及错误（Error），其他的都是检查异常（绝对的大家族）。

![img](https://img-blog.csdnimg.cn/d736e91e7a344d7b977bac580e149318.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5piv5rOi5ZOp5Liq5rOi,size_16,color_FFFFFF,t_70,g_se,x_16)

# JAVA抛出异常和捕获异常如何选择(没搜到合适的答案)

![image-20240425135253174](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240425135253174.png)



# SpringMvc执行流程

![image-20240429122327588](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429122327588.png)

![image-20240429122342651](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429122342651.png)

# 过滤器和拦截器的区别

相同
二者都是体现了AOP的思想，都可以实现诸如日志记录、登录鉴权等功能，但二者的不同点也是比较多的，接下来一一说明。

1.底层原理
拦截器是使用反射进行实现，过滤器是基于函数回调进行实现

2.使用范围不同
过滤器 实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器Filter 的使用要依赖于Tomcat等容器，导致它只能在web程序中使用。

拦截器(Interceptor) 它是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。不仅能应用在web程序中，也可以用于Application、Swing等程序中。

3.触发时机不同过滤器

`Filter`是在请求进入容器后，但在进入`servlet`之前进行预处理，请求结束是在`servlet`处理完以后。

拦截器 `Interceptor` 是在请求进入`servlet`后，在进入`Controller`之前进行预处理的，`Controller` 中渲染了对应的视图之后请求结束。·

# 后端如何接收前端请求体的请求？有没有看过底层源码？（不会

# 项目中为什么要用webSocket?webSocket和http有什么区别？

使用 Websocket 来实现用户端和商家端通信：
WebSocket 是一种在 Web 应用程序中实现双向通信的协议。它允许客户端和服务器之间建立持久的、双向的通信通道，使得服务器可以主动向客户端推送消息，而无需客户端发送请求。
客户端和服务器之间可以实时地发送消息和接收消息，不需要频繁地发起请求。这样可以减少网络流量和延迟，并提供更好的用户体验。
![image-20240429125341003](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429125341003.png)

# 讲一下Redis

> Redis 是**高性能的**，**基于键值对的**，**写入缓存的** 内存[存储系统](https://so.csdn.net/so/search?q=存储系统&spm=1001.2101.3001.7020)。它支持多种数据结构如字符串、哈希表、列表、集合、有序集合等，并提供了丰富的操作命令

[Redisopen in new window](https://redis.io/) （**RE**mote **DI**ctionary **S**erver）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。

为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、发布订阅模型、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。

# Redis集群

在Redis中提供的集群方案总共有三种

主从复制

哨兵模式

分片集群

![image-20240501151531067](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240501151531067.png)

![image-20240501151601517](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240501151601517.png)

![image-20240501151626458](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240501151626458.png)

# Redis在你项目中用在哪里？Redis还能用来干嘛

项目中引入 Redis 的地方是：

1. 查询店铺营业状态 ，像这种店铺营业状态，本项目无非就两个状态：营业中/打样。而且它属于高频查询。只要用户浏览到这个店铺，前端就要自动发送请求到后端查询店铺状态。Redis 是基于键值对这种形式存储的，而且 Redis 也把将数据放到缓存中，而不是磁盘，有效缓解了这种高频查询给磁盘带来的压力。
2.缓存菜品 用户端小程序展示的菜品数据都是通过查询数据库获得，如果用户端访问量比较大，数据库访问压力随之增大。**结果：**系统响应慢、用户体验差。通过Redis来缓存菜品数据，减少数据库查询操作。
3.缓存套餐（用到的是Spring Cache)

Redis还可以用来做缓存  分布式锁  消息队列  延迟队列  搜索引擎





# 项目出现了OOM怎么排查？（java内存泄露的排查思路

![image-20240429130359085](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429130359085.png)

# 一条sql语句执行流程

![image-20240429130844624](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429130844624.png)

![image-20240429130901382](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429130901382.png)

# 讲一下mysql的MVCC

![image-20240429131111107](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429131111107.png)

# 当前读和快照读

![image-20240429131258032](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429131258032.png)

# 数据库是如何解决幻读的？

MySQL在**可重复读**隔离级别下，是通过MVCC机制避免幻读的。

## 普通读（快照读）解决幻读问题

MySQL在可重复读隔离级别下，是通过MVCC机制避免幻读的。

MVCC机制，可以简单理解成在事务启动的时候对数据库拍了个“快照”，它保留了那个时刻数据库的数据状态，那么这个事务后续的读取都可以从这个“快照”中获取，哪怕其他事务新加了数据，也不会影响到“快照”中的数据，也就不会出现幻读了
## 当前读解决幻读问题

也就是说不能读取“**快照**”了，因为你要最新状态的数据，那么能不能在当前读的时候，对这段区间都加上锁，让别的事务阻塞，无法插入。因此，MySQL`InnoDB`引擎为了解决可重复读隔离级别使用当前读而造成的幻读问题，引入了**间隙锁**。

## 总结

MySQL默认采用的隔离级别是可重复读，在这种隔离级别下不同的读模式，针对幻读问题采用了不同解决方案：

针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。
针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。

## mysql索引

![image-20240429131534390](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429131534390.png)

## mysql中索引失效的场景



# 为什么LIKE以%开头索引会失效？



> 分析的时候主要从**多路搜索树的底层B+树的特点，以及命中的条件来回答，B+树是有顺序的，索引失效没有循序B+Tree的顺序法则，导致查询的是无序元素，最终全表扫描，索引失效。**
>
> **具体问题具体分析，围绕B+Tree底层展开。**

![image-20240429133202629](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429133202629.png)

![image-20240429133234760](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429133234760.png)

![image-20240429133307282](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429133307282.png)



# Spring中Bean的自动装配方式

![image-20240518163632932](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240518163632932.png)



# Spring中Bean的生命周期（spring加载流程

![image-20240429134155442](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429134155442.png)

![image-20240429134214077](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429134214077.png)

# 讲一下你对Spring的理解

**广义的 Spring：Spring 技术栈**（全家桶）

广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。

经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。

**狭义的 Spring：Spring Framework**（基础框架）

狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。

Spring Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。

Spring全家桶的其他框架都是以SpringFramework框架为基础！

**spring framework主要功能模块**

![image-20240508181048991](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240508181048991.png)



# Spring，Spring Boot，Spring MVC的关系



Spring 包含了多个功能模块（上面刚刚提到过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。

Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。

使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！

Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。

Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240511140444849.png" alt="image-20240511140444849" style="zoom:67%;" />

# spring的ioc和aop怎么用？AOP是如何实现的？

## IOC

**IoC（Inversion of Control:控制反转）** 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。

- **控制** ：指的是对象创建（实例化、管理）的权力
- **反转** ：控制权交给外部环境（IoC 容器）

将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。

在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。

在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。

Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。

## AOP

AOP（Aspect Oriented Programming）即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。

AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。

### AOP的实现方式

AOP 的常见实现方式有动态代理、字节码操作等方式。

Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 **JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 **Cglib** 生成一个被代理对象的子类来作为代理

**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。** Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。

Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，

# AOP的通知类型

![image-20240508182200753](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240508182200753.png)

# spring 事务(spring是如何管理事务的？)

spring支持2种类型的事务管理

**编程式事务管理**

通过 `TransactionTemplate`或者`TransactionManager`手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。

**声明式事务管理**

推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于`@Transactional` 的全注解方式使用最多）。如果一个类或者一个类中的 public 方法上被标注`@Transactional` 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被`@Transactional` 注解的 public 方法的时候，实际调用的是，`TransactionInterceptor` 类中的 `invoke()`方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。

[`@Transactional` 的作用范围](#transactional-的作用范围)

1. **方法**：推荐将注解使用于方法上，不过需要注意的是：**该注解只能应用到 public 方法上，否则不生效。**

2. **类**：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。

   

[`@Transactional` 的使用注意事项总结](#transactional-的使用注意事项总结)

- `@Transactional` 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；
- 避免同一个类中调用 `@Transactional` 注解的方法，这样会导致事务失效；
- 正确的设置 `@Transactional` 的 `rollbackFor` 和 `propagation` 属性，否则事务可能会回滚失败;
- 被 `@Transactional` 注解的方法所在的类必须被 Spring 管理，否则不生效；
- 底层使用的数据库必须支持事务机制，否则不生效；

## spring中事务失效的场景

异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出

Spring 默认只会回滚非检查异常，若抛出检查异常，要配置rollbackFor属性为Exception

非public方法导致的事务失效，改为public



# mybatis的动态sql

![image-20240511140745152](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240511140745152.png)



# Spring循环依赖如何解决（不太懂

![image-20240429140154142](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429140154142.png)

![image-20240429140229274](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429140229274.png)

![image-20240429140316608](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240429140316608.png)

# 乐观锁和悲观锁

**1.什么是悲观锁？**
悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。

像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
高并发的场景下，激烈的锁竞争会造成[线程阻塞](https://so.csdn.net/so/search?q=线程阻塞&spm=1001.2101.3001.7020)，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。

**2.什么是乐观锁？**
乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。

像 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式 CAS 实现的。
高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试（悲观锁的开销是固定的），这样同样会非常影响性能，导致 CPU 飙升。

**总结**
高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。不过，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。
乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。
CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。
乐观锁的问题：ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作。

# nginx有什么用？为什么要用它？

![image-20240430165833301](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240430165833301.png)

![image-20240430170011530](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240430170011530.png)

# 为什么要负载均衡？负载均衡有什么算法？

> [参考文章](https://blog.csdn.net/wanghangzhen/article/details/118554304?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171446765916800185857036%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171446765916800185857036&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118554304-null-null.142^v100^pc_search_result_base3&utm_term=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&spm=1018.2226.3001.4187)

软件负载均衡从通信层面来看，又可以分为四层和七层负载均衡。

**七层负载均衡**：就是可以根据访问用户的 HTTP 请求头、URL 信息将请求转发到特定的主机。

- DNS 重定向
- HTTP 重定向
- 反向代理

**四层负载均衡**：基于 IP 地址和端口进行请求的转发。

- 修改 IP 地址
- 修改 MAC 地址

nginx实现负载均衡是属于七层负载均衡中的反向代理。

反向代理（Reverse Proxy）方式是指以 代理服务器 来接受网络请求，然后 将请求转发给内网中的服务器，并将从内网中的服务器上得到的结果返回给网络请求的客户端。反向代理负载均衡属于七层负载均衡。

反向代理服务的主流产品：**Nginx、Apache**。

负载均衡算法是负载均衡服务核心中的核心。负载均衡产品多种多样，但是各种负载均衡算法原理是共性的。负载均衡算法有很多种，分别适用于不同的应用场景，本文仅介绍最为常见的负载均衡算法的特性及原理：**轮询、随机、最小活跃数、源地址哈希、一致性哈希**。

**随机（Random）** 算法将请求随机分发到候选服务器。

**轮询（Round Robin）**算法的策略是：将请求依次分发到候选服务器。

**最小活跃数（Least Active）**算法 将请求分发到连接数/请求数最少的候选服务器（目前处理请求最少的服务器）。

**源地址哈希（IP Hash）**算法 根据请求源 IP，通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器。

# JVM中常见的启动参数有哪些？

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240511140820762.png" alt="image-20240511140820762" style="zoom:67%;" />



# JVM中的GC流程

![image-20240430181239349](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240430181239349.png)

# Syncronized的底层原理  锁优化

![image-20240430182337619](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240430182337619.png)

![image-20240430182428458](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240430182428458.png)

# Syncronized修饰static方法和非static方法

1.Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。
2.Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。
3.对于类锁synchronized static，是通过该类直接调用加类锁的方法，而对象锁是创建对象调用加对象锁的方法，两者访问是不冲突的，对于同一类型锁锁住的方法，同一对象是无法同时访问的.



# mysql如何定位慢查询？

介绍一下当时产生问题的场景（我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟）

我们系统中当时采用了运维工具（ Skywalking ），可以监测出哪个接口，最终因为是sql的问题

在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中（调试阶段）

# sql执行计划如何分析？

![image-20240430185656511](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240430185656511.png)

![image-20240430185725029](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240430185725029.png)

![image-20240430185749645](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240430185749645.png)

# RR下如何解决幻读（不懂

[参考文章](https://blog.csdn.net/shichimiyasatone/article/details/131594657?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171447474816800186531133%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171447474816800186531133&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-131594657-null-null.142^v100^pc_search_result_base3&utm_term=%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%8B%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB&spm=1018.2226.3001.4187)



**RR下存在幻读，可以使用间隙锁避免**。

# Linux常用命令有哪些？

详见javaguide

**1.目录切换**

- `cd usr`：切换到该目录下 usr 目录
- `cd ..（或cd../）`：切换到上一层目录

**2.目录操作**

`ls`：显示目录中的文件和子目录的列表。例如：`ls /home`，显示 `/home` 目录下的文件和子目录列表。

`ll`：`ll` 是 `ls -l` 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息

`mkdir [选项] 目录名`：创建新目录（增）。例如：`mkdir -m 755 my_directory`，创建一个名为 `my_directory` 的新目录，并将其权限设置为 755，即所有用户对该目录有读、写和执行的权限。

**3.文件权限**

通过 **`ls -l`** 命令我们可以 查看某个目录下的文件或目录的权限

用户管理

- `useradd [选项] 用户名`:创建用户账号。使用`useradd`指令所建立的帐号，实际上是保存在 `/etc/passwd`文本文件中。
- `userdel [选项] 用户名`:删除用户帐号。

**4.系统状态**

`top [选项]`：用于实时查看系统的 CPU 使用率、内存使用率、进程信息等。

`htop [选项]`：类似于 `top`，但提供了更加交互式和友好的界面，可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。

`uptime [选项]`：用于查看系统总共运行了多长时间、系统的平均负载等信息。

**5.网络通信**

`ping [选项] 目标主机`：测试与目标主机的网络连接。

`ifconfig` 或 `ip`：用于查看系统的网络接口信息，包括网络接口的 IP 地址、MAC 地址、状态等。

`netstat [选项]`：用于查看系统的网络连接状态和网络统计信息，可以查看当前的网络连接情况、监听端口、网络协议等。

**6.其他**

- `sudo + 其他命令`：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。
- `grep 要搜索的字符串 要搜索的文件 --color`：搜索命令，--color 代表高亮显示。

# Linux查看日志用什么？

**第一种:查看实时变化的日志(比较吃内存)**

最常用的:

tail -f filename (默认最后10行,相当于增加参数 -n 10)

**第二种:搜索关键字附近的日志**

最常用的:

cat -n filename |grep “关键字”

**第三种:进入编辑查找:vi(vim)**

1、进入vim编辑模式:vim filename

2、输入“/关键字”,按enter键查找

3、查找下一个,按“n”即可

退出:按ESC键后,接着再输入:号时,vi会在屏幕的最下方等待我们输入命令

wq! 保存退出;

q! 不保存退出;

**第四种（less方式）**

线上出问题的时候,我们常用tail -n 或者 tail -f 或者grep 或者 vi cat等各种命令去查看异常信息,但是日志是在不停地刷屏,tail是动态的在变的,我们往往期望从日志最后一行往前一页一页的翻页查看,从而找到异常信息,而[less命令](https://so.csdn.net/so/search?q=less命令&spm=1001.2101.3001.7020)我觉得是最实用和方便的。

一个日志文件中 我们想从日志的最后一行往前查看 ，就可以用less命令。

第一步:打开日志文件 less sigma.log
第二步:定位到日志文件的最后一行:shift+g移动到最后一行
第三步:ctrl+b往前一页一页翻页查看

# JVM有哪些垃圾收集器？

串行垃圾收集器：Serial GC、Serial Old GC

并行垃圾收集器：Parallel Old GC、ParNew GCCMS

（并发）垃圾收集器：CMS GC，作用在老年代

G1垃圾收集器，作用在新生代和老年代

# 详细说一下G1垃圾回收器

应用于新生代和老年代，在JDK9之后默认使用G1

划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备

采用复制算法

响应时间与吞吐量兼顾

分成三个阶段：新生代回收(stw)、并发标记(重新标记stw)、混合收集,但是前两个阶段的暂停时间都不长，而且他们是并行的

如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC

# 讲一下JVM中一次完整的GC流程

新创建的对象，都会先分配到eden区

当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象

将存活对象采用复制算法复制到to中，复制完毕后，伊甸园和 from 内存都得到释放

经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将其复制到from区

当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会提前晋升）

![image-20240507202346021](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240507202346021.png)

# nginx在项目中的作用是什么？

参考苍穹外卖笔记（反向代理和负载均衡

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d24746663adf44fe9a350daf05273c6a.png)



# JAVA序列化与反序列化

**序列化和反序列化的理解**

两个服务之间要传输一个数据对象，就需要将对象转换成二进制流，通过网络传输到对方服务，再转换成对象，供服务方法调用。这个编码和解码的过程称之为序列化和反序列化。所以序列化就是把 Java 对象变成二进制形式，本质上就是一个byte[]数组。将对象序列化之后，就可以写入磁盘进行保存或者通过网络中输出给远程服务了。反之，反序列化可以从网络或者磁盘中读取的字节数组，反序列化成对象，在程序中使用。

**序列化优点：**
① 永久性保存对象：将对象转为字节流存储到硬盘上，即使 JVM 停机，字节流还会在硬盘上等待，等待下一次 JVM 启动时，反序列化为原来的对象，并且序列化的二进制序列能够减少存储空间

② 方便网络传输：序列化成字节流形式的对象可以方便网络传输（二进制形式），节约网络带宽

③ 通过序列化可以在进程间传递对象

**序列化的几种方式**

1.Java原生序列化：Java 默认通过 Serializable 接口实现序列化，只要实现了该接口，该类就会自动实现序列化与反序列化，该接口没有任何方法，只起标识作用。Java序列化保留了对象类的元数据（如类、成员变量、继承类信息等），以及对象数据等，兼容性最好，但不支持跨语言，而且性能一般。

2.JSON 序列化：JSON是一种轻量级的数据交换格式。JSON 序列化就是将数据对象转换为 JSON 字符串，在序列化过程中抛弃了类型信息，所以反序列化时需要提供类型信息才能准确地反序列化，相比前两种方式，JSON 可读性比较好，方便调试。



# 二叉树三种遍历方式的递归和迭代法描述



# spring boot中的跨域问题如何解决？

浏览器的同源策略(Same Origin Policy)限制了跨域请求。主要出于安全考虑,浏览器限制脚本只能读取与之同源的资源。同源指的是协议、域名、端口都相同。跨域请求会因为违反同源策略而被阻止。

spring boot中实现跨域的几种方式

##### 1.@crossOrigin 注解

我们可以在Controller的方法上直接使用@CrossOrigin注解

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515190450000.png" alt="image-20240515190450000" style="zoom:67%;" />

3.实现WebMvcConfigurer接口，重写addCorsMappings方法

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240515190720711.png" alt="image-20240515190720711" style="zoom:67%;" />

# RestfulAPI和普通API的区别

![image-20240518163711414](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240518163711414.png)



# spring boot 中如何自定义一个starter?(没懂)



# JVM内存泄露问题（得学一下 黑马的总觉得不对



# 如何去优化线程池呢？

# 如果让你去设计一个秒杀系统，你如何去设计？



# Integer.MAX_VALUE + 1的值是多少？

![image-20240528223630134](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240528223630134.png)



# 为什么要使用消息队列?各种消息队列中间件如何选型？



# HashMap如何实现在value有重复时根据value排序呢？





# 手撕题

## 手写数据结构，实现一个队列



## 手写阻塞队列，实现生产者和消费者模式

http://t.csdnimg.cn/lmCwf



## Leecode 234.回文链表



## HashMap里key是自定义对象的情况的排序

http://t.csdnimg.cn/Boen3

1.按key排序
方式一：将哈希表的键（得到HashMap中键的集合(keySet)）转化为数组，使用Arrays.sort()进行排序
方式二：将entrySet转换为List,然后重写比较器，使用Collections.sort（）进行排序
2.按value排序
方式一：将entrySet转换为List,然后重写比较器
———————————————

![image-20240615005353444](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240615005353444.png)

![image-20240615005423576](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240615005423576.png)

![image-20240615005605824](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240615005605824.png)





# 项目

项目的工作以及你攻克的难点或者是亮点的东西

项目拆分的微服务有哪些

大并发/海量数据的情况下，怎么设计系统？从里面拿出2点来问，一个是系统解耦，一个是分库分表





